const App={async init(){console.log("Initializing PrivNext application...");if(localStorage.getItem("e2ee_public_jwk")){if(confirm("Security upgrade available! Clear old keys and generate secure ones?\n\n(You will not be able to read old messages)")){localStorage.removeItem("e2ee_public_jwk");localStorage.removeItem("e2ee_private_jwk");localStorage.setItem("e2ee_migration_complete","true");location.reload()}}
UIManager.init();UIManager.setViewportHeight();IntegrityChecker.initUserInteractionTracking();const socket=io();SocketHandler.init(socket);this.setupSocketCallbacks();this.setupEventListeners();UIManager.updateConnectionStatus(socket.connected,!1);this.updateCharCount();this.registerServiceWorker();console.log("Application initialized successfully")},setupSocketCallbacks(){SocketHandler.onConnectionChange=(isConnected)=>{const canJoin=isConnected&&this.validateInputs();UIManager.updateConnectionStatus(isConnected,canJoin)};SocketHandler.onReconnect=()=>{if(StateManager.currentUser&&StateManager.currentRoomId&&StateManager.userToken&&!StateManager.isJoined){console.log("Auto-reconnecting...");SocketHandler.joinRoom(StateManager.userToken,StateManager.currentRoomId)}};SocketHandler.onErrorReceived=(message)=>{UIManager.showNotification(message,"error")};SocketHandler.onJoinFailed=(message)=>{if(StateManager.joinTimeout){clearTimeout(StateManager.joinTimeout);StateManager.joinTimeout=null}
UIManager.showNotification(message,"error");UIManager.resetJoinButton();StateManager.currentUser=null;StateManager.currentRoomId=null};SocketHandler.onJoinSuccess=async({username,roomId,users})=>{clearTimeout(StateManager.joinTimeout);StateManager.isJoined=!0;StateManager.updateRoomUsers(users);UIManager.showChatView(roomId);try{const publicKey=await E2EE.exportPublicKey();if(publicKey){SocketHandler.sharePublicKey(roomId,publicKey);console.log("E2EE: Public key shared");const fingerprint=await E2EE.getPublicKeyFingerprint();if(fingerprint){console.log(`E2EE: Your key fingerprint: ${fingerprint}`)}}}catch(err){console.warn("E2EE: Failed to share public key:",err)}
if(E2EE.keyPair&&E2EE.keyPair.publicKey){E2EE.peerPublicKeys.set(StateManager.currentUser,E2EE.keyPair.publicKey)}
this.updateActiveUsers();MessageRenderer.updateUsernameVisibility(StateManager.isOneOnOneChat());UIManager.scrollToBottom()};SocketHandler.onPublicKeyReceived=async(username,publicKey)=>{await E2EE.importPublicKey(username,publicKey)};SocketHandler.onRoomKeysReceived=async(publicKeys)=>{for(const[username,publicKey]of Object.entries(publicKeys)){await E2EE.importPublicKey(username,publicKey)}};SocketHandler.onHistoryReceived=async(messages)=>{UIManager.clearMessages();StateManager.displayedUsernames.clear();for(const msg of messages){await this.renderMessage(msg)}
if(messages.length>0){StateManager.lastMessageId=messages[0].messageId}
UIManager.scrollToBottom();this.updateActiveUsers();MessageRenderer.updateUsernameVisibility(StateManager.isOneOnOneChat())};SocketHandler.onMessageReceived=async(data)=>{await this.handleIncomingMessage(data)};SocketHandler.onUsersUpdated=(users)=>{StateManager.updateRoomUsers(users);this.updateActiveUsers();this.updateTypingIndicator();MessageRenderer.updateUsernameVisibility(StateManager.isOneOnOneChat())};SocketHandler.onUserTyping=(username)=>{if(StateManager.addTypingUser(username)){this.updateTypingIndicator();if(UIManager.isScrolledToBottomOrNear()){UIManager.scrollToBottom()}}};SocketHandler.onUserStoppedTyping=(username)=>{StateManager.removeTypingUser(username);this.updateTypingIndicator()};SocketHandler.onMessageStatusChanged=(data)=>{const{messageId,seenBy,roomId}=data;if(roomId!==StateManager.currentRoomId)return;MessageRenderer.updateMessageSeenStatus(messageId,seenBy,StateManager.currentUser,StateManager.totalRoomUsers<3)};SocketHandler.onMessageSeenUpdate=({messageIds})=>{if(StateManager.totalRoomUsers>=3||!messageIds||messageIds.length===0){return}
MessageRenderer.clearSeenStatus();messageIds.forEach((messageId)=>{MessageRenderer.updateMessageSeenStatus(messageId,[],StateManager.currentUser,!0)})}},setupEventListeners(){const{joinButton,usernameInput,roomIdInput,sendButton,messageInput,backButton,downloadButton,imageUpload,messagesContainer,}=UIManager.elements;if(joinButton){joinButton.addEventListener("click",()=>this.joinRoom())}
if(usernameInput){usernameInput.addEventListener("input",()=>this.validateInputs())}
if(roomIdInput){roomIdInput.addEventListener("input",()=>this.validateInputs())}
if(sendButton){sendButton.addEventListener("click",()=>this.sendMessage())}
if(messageInput){messageInput.addEventListener("keydown",(e)=>{if(e.key==="Enter"&&!e.shiftKey){e.preventDefault();this.sendMessage()}});messageInput.addEventListener("input",()=>{this.handleTyping();this.updateCharCount()})}
if(backButton){backButton.addEventListener("click",()=>this.leaveRoom())}
if(downloadButton){downloadButton.addEventListener("click",()=>this.downloadHistory())}
if(imageUpload){imageUpload.addEventListener("change",(e)=>this.handleImageUpload(e))}
if(messagesContainer){messagesContainer.addEventListener("scroll",()=>this.handleScroll())}
window.addEventListener("resize",()=>UIManager.setViewportHeight());window.addEventListener("orientationchange",()=>UIManager.setViewportHeight());window.addEventListener("focus",()=>this.handleFocus())},validateInputs(){const username=UIManager.elements.usernameInput?.value.trim()||"";const roomId=UIManager.elements.roomIdInput?.value.trim()||"";const usernameValid=Validators.validateUsername(username);const roomIdValid=Validators.validateRoomId(roomId);UIManager.validateInputs(usernameValid,roomIdValid);const isValid=usernameValid&&roomIdValid;const canJoin=isValid&&SocketHandler.isConnected();UIManager.updateConnectionStatus(SocketHandler.isConnected(),canJoin);return isValid},async joinRoom(){if(!this.validateInputs()){UIManager.showNotification("Please enter valid username (2-50 chars) and room ID","error");return}
UIManager.setJoinButtonLoading("Verifying...");try{const integrityResult=await IntegrityChecker.performIntegrityCheck();console.log("Browser Integrity Check:",integrityResult);if(!integrityResult.passed){UIManager.showNotification("Browser verification failed. Please use a standard web browser.","error");UIManager.resetJoinButton();return}
UIManager.setJoinButtonLoading("Generating keys...");const e2eeReady=await E2EE.init();if(!e2eeReady){UIManager.showNotification("Failed to initialize encryption. Please refresh.","error");UIManager.resetJoinButton();return}
const username=UIManager.elements.usernameInput.value.trim();const roomId=UIManager.elements.roomIdInput.value.trim();window.E2EE_SELF_USERNAME=username;if(E2EE.keyPair&&E2EE.keyPair.publicKey){E2EE.peerPublicKeys.set(username,E2EE.keyPair.publicKey)}
UIManager.setJoinButtonLoading("Authenticating...");const token=await APIHandler.authenticate(username);StateManager.userToken=token;StateManager.currentUser=username;StateManager.currentRoomId=roomId;UIManager.setJoinButtonLoading("Joining...");SocketHandler.joinRoom(token,roomId,integrityResult.token,integrityResult.score);StateManager.joinTimeout=setTimeout(()=>{if(!StateManager.isJoined){UIManager.showNotification("Connection timeout. Please try again.","error");UIManager.resetJoinButton()}},10000)}catch(error){console.error("Join error:",error);UIManager.showNotification("Failed to join room: "+error.message,"error");UIManager.resetJoinButton()}},async sendMessage(){const messageInput=UIManager.elements.messageInput;const message=messageInput?.value.trim()||"";if(StateManager.imageFile){await this.uploadImage();return}
if(!message){UIManager.showNotification("Please enter a message.","error");return}
if(!StateManager.isJoined||!StateManager.currentRoomId){UIManager.showNotification("You must join a room first.","error");return}
const recipients=StateManager.getEncryptionRecipients();const encryptedData=await E2EE.encryptMessage(message,recipients);if(!encryptedData){UIManager.showNotification("Failed to encrypt message.","error");return}
SocketHandler.sendMessage(StateManager.currentRoomId,encryptedData);UIManager.resetMessageInput();this.updateCharCount();SocketHandler.stopTyping(StateManager.currentRoomId)},async handleIncomingMessage(data){const{user,encryptedData,messageId,timestamp,seenBy}=data;const isCurrentUser=user===StateManager.currentUser;let decryptedMessage="[Encrypted]";if(encryptedData&&encryptedData.encryptedKeys){const encryptedKey=encryptedData.encryptedKeys[StateManager.currentUser];if(encryptedKey){try{decryptedMessage=await E2EE.decryptMessage(encryptedData,encryptedKey)}catch(error){console.error("Decryption failed:",error);decryptedMessage="[Decryption Failed]"}}else{decryptedMessage="[Not encrypted for you]"}}
const seenStatus=seenBy&&seenBy.length>=2&&isCurrentUser;const userColor=isCurrentUser?null:StateManager.assignUserColor(user);const messageElement=MessageRenderer.createMessageElement(user,decryptedMessage,isCurrentUser,timestamp,null,messageId,seenStatus,userColor);UIManager.appendMessage(messageElement);if(UIManager.isScrolledToBottomOrNear()){UIManager.scrollToBottom()}
if(!isCurrentUser&&document.hasFocus()&&StateManager.isJoined){if(StateManager.seenTimeout){clearTimeout(StateManager.seenTimeout)}
StateManager.seenTimeout=setTimeout(()=>{SocketHandler.markAllSeen(StateManager.currentRoomId)},StateManager.CONFIG.seenDebounce)}},async renderMessage(msg){const isCurrentUser=msg.username===StateManager.currentUser;let displayMessage=msg.message;if(msg.encryptedData){const encryptedKey=msg.encryptedData.encryptedKeys?.[StateManager.currentUser];if(encryptedKey){try{displayMessage=await E2EE.decryptMessage(msg.encryptedData,encryptedKey)}catch(error){console.error("Decryption failed:",error);displayMessage="[Decryption Failed]"}}else{displayMessage="[Not encrypted for you]"}}
const seenStatus=msg.seenBy&&msg.seenBy.length>=2&&isCurrentUser;const userColor=isCurrentUser?null:StateManager.assignUserColor(msg.username);const messageElement=MessageRenderer.createMessageElement(msg.username,displayMessage,isCurrentUser,msg.timestamp,msg.imageUrl,msg.messageId,seenStatus,userColor);UIManager.appendMessage(messageElement)},handleTyping(){if(!StateManager.isJoined)return;const message=UIManager.elements.messageInput?.value.trim()||"";if(message.length>0){SocketHandler.typing(StateManager.currentRoomId)}else{SocketHandler.stopTyping(StateManager.currentRoomId)}
if(StateManager.typingTimeout){clearTimeout(StateManager.typingTimeout)}
StateManager.typingTimeout=setTimeout(()=>{SocketHandler.stopTyping(StateManager.currentRoomId)},StateManager.CONFIG.typingDebounce)},updateCharCount(){const messageInput=UIManager.elements.messageInput;if(!messageInput)return;const currentLength=messageInput.value.length;const maxLength=StateManager.CONFIG.maxMessageLength;UIManager.updateCharCount(currentLength,maxLength);const isValid=currentLength>0&&currentLength<=maxLength;UIManager.updateSendButton(isValid,!!StateManager.imageFile)},updateActiveUsers(){const otherUsers=StateManager.getOtherUsers();UIManager.updateActiveUsers(StateManager.currentUser,otherUsers,StateManager.totalRoomUsers)},updateTypingIndicator(){const typingUsers=StateManager.getTypingUsers();UIManager.updateTypingIndicator(typingUsers)},handleImageUpload(event){const file=event.target.files[0];StateManager.clearImageFile();UIManager.resetMessageInput();if(!file)return;const validation=Validators.validateImageFile(file,StateManager.CONFIG.maxFileSize);if(!validation.valid){UIManager.showNotification(validation.error,"error");event.target.value="";return}
StateManager.setImageFile(file);UIManager.updateInputForImage(file.name);UIManager.updateSendButton(!1,!0)},async uploadImage(){if(!StateManager.imageFile||!StateManager.isJoined){UIManager.showNotification("No image selected or not in room.","error");return}
if(!StateManager.userToken){UIManager.showNotification("Authentication required. Please rejoin.","error");return}
UIManager.elements.messageInput.disabled=!0;UIManager.setSendButtonLoading(!0);try{const result=await APIHandler.uploadImage(StateManager.imageFile,StateManager.currentRoomId,StateManager.userToken);UIManager.showNotification("Image uploaded successfully.","info")}catch(error){UIManager.showNotification("Image upload failed: "+error.message,"error")}finally{StateManager.clearImageFile();UIManager.resetMessageInput();UIManager.setSendButtonLoading(!1);UIManager.updateSendButton(!1,!1)}},async handleScroll(){const messagesContainer=UIManager.elements.messagesContainer;if(!messagesContainer)return;const isNearTop=messagesContainer.scrollTop<100;if(isNearTop&&StateManager.isJoined&&!StateManager.isLoadingMoreMessages&&StateManager.lastMessageId){StateManager.isLoadingMoreMessages=!0;UIManager.setLoadingIndicator(!0);try{const messages=await APIHandler.loadOlderMessages(StateManager.currentRoomId,StateManager.lastMessageId,20);if(messages.length>0){const oldScrollHeight=UIManager.getScrollHeight();for(const msg of messages){const isCurrentUser=msg.username===StateManager.currentUser;const seenStatus=msg.seenBy&&msg.seenBy.length>=2&&isCurrentUser;const userColor=isCurrentUser?null:StateManager.assignUserColor(msg.username);const messageElement=MessageRenderer.createMessageElement(msg.username,msg.message,isCurrentUser,msg.timestamp,msg.imageUrl,msg.messageId,seenStatus,userColor);UIManager.prependMessage(messageElement)}
StateManager.lastMessageId=messages[0].messageId;const newScrollHeight=UIManager.getScrollHeight();UIManager.setScrollTop(newScrollHeight-oldScrollHeight);if(messages.length<20){UIManager.showNotification("All messages loaded.","info")}}else{StateManager.lastMessageId=null;UIManager.showNotification("No more messages.","info")}}catch(error){UIManager.showNotification("Failed to load older messages.","error")}finally{StateManager.isLoadingMoreMessages=!1;UIManager.setLoadingIndicator(!1)}}},handleFocus(){if(StateManager.isJoined&&StateManager.currentRoomId){if(StateManager.seenTimeout){clearTimeout(StateManager.seenTimeout)}
StateManager.seenTimeout=setTimeout(()=>{SocketHandler.markAllSeen(StateManager.currentRoomId)},StateManager.CONFIG.seenDebounce)}},downloadHistory(){if(!StateManager.isJoined){UIManager.showNotification("Please join a room first.","error");return}
const history=MessageRenderer.createChatHistory(StateManager.currentUser);if(!history||history.length===0){UIManager.showNotification("No messages to download.","info");return}
const jsonString=JSON.stringify(history,null,2);const blob=new Blob([jsonString],{type:"application/json"});const url=URL.createObjectURL(blob);const a=document.createElement("a");a.href=url;a.download=`SecureChat_History_${StateManager.currentRoomId}_${new Date().toISOString().substring(0, 10)}.json`;document.body.appendChild(a);a.click();document.body.removeChild(a);URL.revokeObjectURL(url);UIManager.showNotification("Chat history downloaded.","info")},leaveRoom(){if(!confirm("Are you sure you want to leave this room?")){return}
SocketHandler.leaveRoom();StateManager.isJoined=!1;StateManager.userToken=null;E2EE.peerPublicKeys.clear();UIManager.showLoginView();StateManager.typingUsers.clear();this.updateTypingIndicator();UIManager.updateConnectionStatus(SocketHandler.isConnected(),!1)},registerServiceWorker(){if("serviceWorker" in navigator){navigator.serviceWorker.getRegistration("/").then((registration)=>{if(registration){registration.unregister().then((success)=>{if(success){console.log("Service Worker successfully unregistered and removed control.")}else{console.warn("Service Worker unregistration failed or returned false.")}}).catch((error)=>{console.error("Error during Service Worker unregistration:",error)})}else{console.log("No existing Service Worker found to unregister.")}})}else{console.log("Service Workers not supported in this browser.")}},};document.addEventListener("DOMContentLoaded",()=>{App.init()});if(typeof window!=="undefined"){window.App=App;window._debugState=()=>StateManager.debug();window._debugE2EE=()=>E2EE}
