const E2EE={keyPair:null,peerPublicKeys:new Map(),peerFingerprints:new Map(),verifiedPeers:new Set(),autoAcceptedPeers:new Set(),keyGenerationDate:null,decryptionFailures:new Map(),sessionKeys:new Map(),messageStore:new Map(),KEY_EXPIRY_DAYS:30,MAX_DECRYPTION_RETRIES:3,MESSAGE_RETENTION_DAYS:30,KEY_ROTATION_CHECK_INTERVAL:24*60*60*1000,_openIDB(){return new Promise((resolve,reject)=>{if(!('indexedDB' in window))return reject(new Error('indexedDB not supported'));const req=indexedDB.open('e2ee-secure-db',2);req.onupgradeneeded=(e)=>{const db=e.target.result;if(!db.objectStoreNames.contains('keys')){db.createObjectStore('keys')}
if(!db.objectStoreNames.contains('messages')){const msgStore=db.createObjectStore('messages',{keyPath:'id',autoIncrement:!0});msgStore.createIndex('room','room',{unique:!1});msgStore.createIndex('timestamp','timestamp',{unique:!1})}
if(!db.objectStoreNames.contains('roomKeys')){db.createObjectStore('roomKeys')}};req.onsuccess=()=>resolve(req.result);req.onerror=()=>reject(req.error)})},async _idbPut(storeName,key,value){const db=await this._openIDB();return new Promise((resolve,reject)=>{const tx=db.transaction([storeName],'readwrite');const store=tx.objectStore(storeName);const r=storeName==='messages'?store.add(value):store.put(value,key);r.onsuccess=()=>{resolve(r.result);db.close()};r.onerror=()=>{reject(r.error||new Error('IDB put failed'));db.close()}})},async _idbGet(storeName,key){const db=await this._openIDB();return new Promise((resolve,reject)=>{const tx=db.transaction([storeName],'readonly');const store=tx.objectStore(storeName);const r=store.get(key);r.onsuccess=()=>{resolve(r.result);db.close()};r.onerror=()=>{reject(r.error||new Error('IDB get failed'));db.close()}})},async _idbGetAll(storeName,indexName,query){const db=await this._openIDB();return new Promise((resolve,reject)=>{const tx=db.transaction([storeName],'readonly');const store=tx.objectStore(storeName);const index=indexName?store.index(indexName):store;const r=query?index.getAll(query):index.getAll();r.onsuccess=()=>{resolve(r.result||[]);db.close()};r.onerror=()=>{reject(r.error||new Error('IDB getAll failed'));db.close()}})},async _idbDelete(storeName,key){const db=await this._openIDB();return new Promise((resolve,reject)=>{const tx=db.transaction([storeName],'readwrite');const store=tx.objectStore(storeName);const r=store.delete(key);r.onsuccess=()=>{resolve(!0);db.close()};r.onerror=()=>{reject(r.error||new Error('IDB delete failed'));db.close()}})},needsKeyRotation(){if(!this.keyGenerationDate)return!1;return this.areKeysExpired(this.keyGenerationDate)},async rotateKeysWithMessages(){console.log("E2EE: Starting key rotation with message re-encryption...");try{const allMessages=await this._idbGetAll('messages');const roomMap=new Map();for(const msg of allMessages){if(!roomMap.has(msg.room)){roomMap.set(msg.room,[])}
roomMap.get(msg.room).push(msg)}
console.log(`E2EE: Found ${roomMap.size} rooms with messages to re-encrypt`);const decryptedMessages=new Map();for(const[room,messages]of roomMap){const roomKey=this.sessionKeys.get(room)||await this.getOrCreateRoomKey(room,'system');const decrypted=[];for(const record of messages){try{const encrypted=this.base64ToArrayBuffer(record.encrypted);const iv=this.base64ToArrayBuffer(record.iv);const decryptedData=await crypto.subtle.decrypt({name:'AES-GCM',iv},roomKey,encrypted);const decoder=new TextDecoder();const msgData=JSON.parse(decoder.decode(decryptedData));decrypted.push({...msgData,originalTimestamp:record.timestamp,id:record.id})}catch(err){console.warn(`E2EE: Could not decrypt message ${record.id} during rotation:`,err)}}
decryptedMessages.set(room,decrypted)}
console.log(`E2EE: Decrypted ${decryptedMessages.size} rooms of messages`);const oldKeyPair=this.keyPair;this.keyPair=await crypto.subtle.generateKey({name:"RSA-OAEP",modulusLength:2048,publicExponent:new Uint8Array([1,0,1]),hash:"SHA-256"},!1,["encrypt","decrypt"]);this.keyGenerationDate=Date.now();await this.saveKeyPair();console.log("E2EE: New keypair generated and saved");this.sessionKeys.clear();const db=await this._openIDB();const tx=db.transaction(['roomKeys'],'readwrite');const store=tx.objectStore('roomKeys');await new Promise((resolve,reject)=>{const clearReq=store.clear();clearReq.onsuccess=()=>resolve();clearReq.onerror=()=>reject(clearReq.error)});db.close();console.log("E2EE: Old room keys cleared");for(const[room,messages]of decryptedMessages){const newRoomKey=await this.getOrCreateRoomKey(room,'system');for(const msg of messages){try{const iv=crypto.getRandomValues(new Uint8Array(12));const encoder=new TextEncoder();const msgData=JSON.stringify({content:msg.content,sender:msg.sender,timestamp:msg.timestamp,isOutgoing:msg.isOutgoing,encrypted:msg.encrypted,encryptedData:msg.encryptedData});const encrypted=await crypto.subtle.encrypt({name:'AES-GCM',iv},newRoomKey,encoder.encode(msgData));if(msg.id){await this._idbDelete('messages',msg.id)}
await this._idbPut('messages',null,{room:room,encrypted:this.arrayBufferToBase64(encrypted),iv:this.arrayBufferToBase64(iv),hmac:'',timestamp:msg.originalTimestamp||Date.now()})}catch(err){console.error(`E2EE: Failed to re-encrypt message:`,err)}}}
console.log(`âœ“ E2EE: Successfully rotated keys and re-encrypted ${decryptedMessages.size} rooms of messages`);if(typeof window!=='undefined'&&window.UIManager){window.UIManager.showNotification("ðŸ”„ Encryption keys rotated successfully. Your messages are secure.","success")}
if(typeof window!=='undefined'&&window.SocketHandler){const newPublicKey=await this.exportPublicKey();window.SocketHandler.broadcastPublicKeyUpdate(newPublicKey)}
return!0}catch(err){console.error("E2EE: Key rotation failed:",err);if(typeof window!=='undefined'&&window.UIManager){window.UIManager.showNotification("âš ï¸ Key rotation failed. Please try again or contact support.","error")}
return!1}},async checkAndRotateKeys(){if(this.needsKeyRotation()){console.log("E2EE: Automatic key rotation triggered");return await this.rotateKeysWithMessages()}
return!1},startKeyRotationScheduler(){this.checkAndRotateKeys();this.keyRotationInterval=setInterval(()=>{this.checkAndRotateKeys()},this.KEY_ROTATION_CHECK_INTERVAL);console.log("âœ“ E2EE: Key rotation scheduler started")},stopKeyRotationScheduler(){if(this.keyRotationInterval){clearInterval(this.keyRotationInterval);this.keyRotationInterval=null;console.log("E2EE: Key rotation scheduler stopped")}},async rotateRoomKey(roomName,username){console.log(`E2EE: Rotating room key for ${roomName}...`);try{const oldKey=this.sessionKeys.get(roomName)||await this.getOrCreateRoomKey(roomName,username);const stored=await this._idbGetAll('messages','room',roomName);const decryptedMessages=[];for(const record of stored){try{const encrypted=this.base64ToArrayBuffer(record.encrypted);const iv=this.base64ToArrayBuffer(record.iv);const decrypted=await crypto.subtle.decrypt({name:'AES-GCM',iv},oldKey,encrypted);const decoder=new TextDecoder();const msgData=JSON.parse(decoder.decode(decrypted));decryptedMessages.push({...msgData,originalTimestamp:record.timestamp,id:record.id})}catch(err){console.warn(`E2EE: Could not decrypt message during room key rotation:`,err)}}
const newRoomKey=await crypto.subtle.generateKey({name:'AES-GCM',length:256},!0,['encrypt','decrypt']);const rawKey=await crypto.subtle.exportKey('raw',newRoomKey);await this._idbPut('roomKeys',roomName,{key:this.arrayBufferToBase64(rawKey),created:Date.now(),username:username,rotated:!0});this.sessionKeys.set(roomName,newRoomKey);for(const msg of decryptedMessages){if(msg.id){await this._idbDelete('messages',msg.id)}}
for(const msg of decryptedMessages){const iv=crypto.getRandomValues(new Uint8Array(12));const encoder=new TextEncoder();const msgData=JSON.stringify({content:msg.content,sender:msg.sender,timestamp:msg.timestamp,isOutgoing:msg.isOutgoing,encrypted:msg.encrypted,encryptedData:msg.encryptedData});const encrypted=await crypto.subtle.encrypt({name:'AES-GCM',iv},newRoomKey,encoder.encode(msgData));await this._idbPut('messages',null,{room:roomName,encrypted:this.arrayBufferToBase64(encrypted),iv:this.arrayBufferToBase64(iv),hmac:'',timestamp:msg.originalTimestamp||Date.now()})}
console.log(`âœ“ E2EE: Rotated room key and re-encrypted ${decryptedMessages.length} messages for ${roomName}`);return!0}catch(err){console.error(`E2EE: Room key rotation failed for ${roomName}:`,err);return!1}},async exportMessagesBackup(password){try{const allMessages=await this._idbGetAll('messages');const allRoomKeys={};for(const[room,key]of this.sessionKeys){const rawKey=await crypto.subtle.exportKey('raw',key);allRoomKeys[room]=this.arrayBufferToBase64(rawKey)}
const backupData={version:'3.0',timestamp:Date.now(),messages:allMessages,roomKeys:allRoomKeys,verifiedPeers:Array.from(this.verifiedPeers)};const encoder=new TextEncoder();const salt=crypto.getRandomValues(new Uint8Array(16));const passwordKey=await crypto.subtle.importKey('raw',encoder.encode(password),{name:'PBKDF2'},!1,['deriveBits','deriveKey']);const aesKey=await crypto.subtle.deriveKey({name:'PBKDF2',salt:salt,iterations:250000,hash:'SHA-256'},passwordKey,{name:'AES-GCM',length:256},!1,['encrypt']);const iv=crypto.getRandomValues(new Uint8Array(12));const encrypted=await crypto.subtle.encrypt({name:'AES-GCM',iv},aesKey,encoder.encode(JSON.stringify(backupData)));return{version:'3.0',salt:this.arrayBufferToBase64(salt),iv:this.arrayBufferToBase64(iv),data:this.arrayBufferToBase64(encrypted),timestamp:Date.now()}}catch(err){console.error("E2EE: Backup export failed:",err);return null}},async importMessagesBackup(encryptedBackup,password){try{const encoder=new TextEncoder();const decoder=new TextDecoder();const passwordKey=await crypto.subtle.importKey('raw',encoder.encode(password),{name:'PBKDF2'},!1,['deriveBits','deriveKey']);const salt=this.base64ToArrayBuffer(encryptedBackup.salt);const aesKey=await crypto.subtle.deriveKey({name:'PBKDF2',salt:salt,iterations:250000,hash:'SHA-256'},passwordKey,{name:'AES-GCM',length:256},!1,['decrypt']);const iv=this.base64ToArrayBuffer(encryptedBackup.iv);const encryptedData=this.base64ToArrayBuffer(encryptedBackup.data);const decrypted=await crypto.subtle.decrypt({name:'AES-GCM',iv},aesKey,encryptedData);const backupData=JSON.parse(decoder.decode(decrypted));for(const[room,keyB64]of Object.entries(backupData.roomKeys)){const rawKey=this.base64ToArrayBuffer(keyB64);const roomKey=await crypto.subtle.importKey('raw',rawKey,{name:'AES-GCM',length:256},!1,['encrypt','decrypt']);this.sessionKeys.set(room,roomKey);await this._idbPut('roomKeys',room,{key:keyB64,created:Date.now(),restored:!0})}
for(const msg of backupData.messages){await this._idbPut('messages',null,msg)}
if(backupData.verifiedPeers){this.verifiedPeers=new Set(backupData.verifiedPeers);await this.saveVerifiedPeers()}
console.log(`âœ“ E2EE: Restored ${backupData.messages.length} messages from backup`);return!0}catch(err){console.error("E2EE: Backup import failed:",err);return!1}},async deriveStorageKey(username,seed){const encoder=new TextEncoder();const keyMaterial=encoder.encode(username+'|'+seed);const hashBuffer=await crypto.subtle.digest('SHA-256',keyMaterial);return await crypto.subtle.importKey('raw',hashBuffer,{name:'AES-GCM',length:256},!1,['encrypt','decrypt'])},async saveKeyPair(){try{const spki=await crypto.subtle.exportKey("spki",this.keyPair.publicKey);const publicKeyB64=this.arrayBufferToBase64(spki);this.keyGenerationDate=this.keyGenerationDate||Date.now();await this._idbPut('keys','privateKey',this.keyPair.privateKey);await this._idbPut('keys','publicKey',publicKeyB64);await this._idbPut('keys','meta',{createdAt:this.keyGenerationDate,version:'3.0',type:'non-exportable'});console.log("âœ“ E2EE: Private key persisted securely in IndexedDB (non-exportable)");return!0}catch(err){console.warn("âš  E2EE: IndexedDB persistence failed. Keys will be session-only.",err);console.warn("âš  E2EE: Messages will not persist across sessions without key persistence.");return!1}},async loadKeyPair(){try{const priKey=await this._idbGet('keys','privateKey');const pubKeyB64=await this._idbGet('keys','publicKey');const meta=await this._idbGet('keys','meta');if(!priKey||!pubKeyB64){console.log("E2EE: No persisted keys found");return!1}
const pubBuf=this.base64ToArrayBuffer(pubKeyB64);const pubKey=await crypto.subtle.importKey("spki",pubBuf,{name:"RSA-OAEP",hash:"SHA-256"},!0,["encrypt"]);this.keyPair={publicKey:pubKey,privateKey:priKey};this.keyGenerationDate=(meta&&meta.createdAt)?meta.createdAt:Date.now();if(this.areKeysExpired(this.keyGenerationDate)){console.warn("âš  E2EE: Keys expired, regeneration recommended");this.showKeyExpiryWarning()}
console.log("âœ“ E2EE: Loaded non-exportable keys from IndexedDB");return!0}catch(err){console.error("E2EE: Failed to load keys:",err);return!1}},areKeysExpired(createdAt){if(!createdAt)return!1;const age=Date.now()-createdAt;const expiryMs=this.KEY_EXPIRY_DAYS*24*60*60*1000;return age>expiryMs},showKeyExpiryWarning(){if(typeof window!=='undefined'&&window.UIManager){window.UIManager.showNotification("âš ï¸ Your encryption keys are older than 30 days. Consider regenerating for better security.","warning")}},async init(){const loaded=await this.loadKeyPair();if(loaded){await this.loadVerifiedPeers();this.startKeyRotationScheduler();return!0}
console.log("E2EE: Generating new RSA key pair (non-exportable)...");this.keyPair=await crypto.subtle.generateKey({name:"RSA-OAEP",modulusLength:2048,publicExponent:new Uint8Array([1,0,1]),hash:"SHA-256"},!1,["encrypt","decrypt"]);this.keyGenerationDate=Date.now();await this.saveKeyPair();console.log("âœ“ E2EE: New key pair created");this.startKeyRotationScheduler();return!0},async rotateKeys(){console.log("E2EE: Manual key rotation requested...");return await this.rotateKeysWithMessages()},async clearKeys(){this.stopKeyRotationScheduler();this.keyPair=null;this.peerPublicKeys.clear();this.peerFingerprints.clear();this.verifiedPeers.clear();this.keyGenerationDate=null;this.decryptionFailures.clear();this.sessionKeys.clear();this.messageStore.clear();try{await this._idbDelete('keys','privateKey').catch(()=>{});await this._idbDelete('keys','publicKey').catch(()=>{});await this._idbDelete('keys','meta').catch(()=>{})}catch(err){console.error("E2EE: Error clearing keys:",err)}
console.log("âœ“ E2EE: All keys cleared")},async getOrCreateRoomKey(roomName,username){if(this.sessionKeys.has(roomName)){return this.sessionKeys.get(roomName)}
try{const stored=await this._idbGet('roomKeys',roomName);if(stored){const key=await crypto.subtle.importKey('raw',this.base64ToArrayBuffer(stored.key),{name:'AES-GCM',length:256},!1,['encrypt','decrypt']);this.sessionKeys.set(roomName,key);return key}}catch(err){console.warn("E2EE: Could not load room key, generating new:",err)}
const roomKey=await crypto.subtle.generateKey({name:'AES-GCM',length:256},!0,['encrypt','decrypt']);try{const rawKey=await crypto.subtle.exportKey('raw',roomKey);await this._idbPut('roomKeys',roomName,{key:this.arrayBufferToBase64(rawKey),created:Date.now(),username:username})}catch(err){console.warn("E2EE: Could not persist room key:",err)}
this.sessionKeys.set(roomName,roomKey);return roomKey},async storeMessage(roomName,message,isOutgoing,username){try{const roomKey=await this.getOrCreateRoomKey(roomName,username);const iv=crypto.getRandomValues(new Uint8Array(12));const encoder=new TextEncoder();const msgData=JSON.stringify({content:message.content||message.message,sender:message.sender||message.username,timestamp:message.timestamp||Date.now(),isOutgoing:isOutgoing,encrypted:message.encrypted||!1,encryptedData:message.encryptedData||null});const encrypted=await crypto.subtle.encrypt({name:'AES-GCM',iv},roomKey,encoder.encode(msgData));const hmacKey=await crypto.subtle.importKey('raw',crypto.getRandomValues(new Uint8Array(32)),{name:'HMAC',hash:'SHA-256'},!1,['sign']);const hmac=await crypto.subtle.sign('HMAC',hmacKey,encrypted);await this._idbPut('messages',null,{room:roomName,encrypted:this.arrayBufferToBase64(encrypted),iv:this.arrayBufferToBase64(iv),hmac:this.arrayBufferToBase64(hmac),timestamp:Date.now()});console.log("âœ“ E2EE: Message stored securely")}catch(err){console.error("E2EE: Failed to store message:",err)}},async loadMessages(roomName,username){try{const roomKey=await this.getOrCreateRoomKey(roomName,username);const stored=await this._idbGetAll('messages','room',roomName);const messages=[];for(const record of stored){try{const encrypted=this.base64ToArrayBuffer(record.encrypted);const iv=this.base64ToArrayBuffer(record.iv);const decrypted=await crypto.subtle.decrypt({name:'AES-GCM',iv},roomKey,encrypted);const decoder=new TextDecoder();const msgData=JSON.parse(decoder.decode(decrypted));messages.push(msgData)}catch(err){console.warn("E2EE: Could not decrypt stored message:",err)}}
messages.sort((a,b)=>a.timestamp-b.timestamp);console.log(`âœ“ E2EE: Loaded ${messages.length} messages for ${roomName}`);return messages}catch(err){console.error("E2EE: Failed to load messages:",err);return[]}},async clearOldMessages(){try{const cutoff=Date.now()-(this.MESSAGE_RETENTION_DAYS*24*60*60*1000);const db=await this._openIDB();const tx=db.transaction(['messages'],'readwrite');const store=tx.objectStore('messages');const index=store.index('timestamp');const range=IDBKeyRange.upperBound(cutoff);let deleted=0;const request=index.openCursor(range);await new Promise((resolve,reject)=>{request.onsuccess=(e)=>{const cursor=e.target.result;if(cursor){cursor.delete();deleted++;cursor.continue()}else{resolve()}};request.onerror=()=>reject(request.error)});db.close();console.log(`âœ“ E2EE: Deleted ${deleted} old messages`)}catch(err){console.error("E2EE: Failed to clear old messages:",err)}},async getPublicKeyFingerprint(publicKey=null){try{const key=publicKey||this.keyPair.publicKey;const spki=await crypto.subtle.exportKey("spki",key);const hash=await crypto.subtle.digest("SHA-256",spki);const fingerprint=Array.from(new Uint8Array(hash)).map(x=>x.toString(16).padStart(2,"0")).join("");return fingerprint.match(/.{1,4}/g).join(' ').toUpperCase().substring(0,47)}catch(err){console.error("E2EE: Failed to generate fingerprint:",err);return null}},async getShortFingerprint(publicKey=null){const full=await this.getPublicKeyFingerprint(publicKey);if(!full)return null;return full.split(' ').slice(0,6).join(' ')},async storePeerFingerprint(username,publicKey){const fingerprint=await this.getPublicKeyFingerprint(publicKey);if(fingerprint){this.peerFingerprints.set(username,fingerprint)}},async verifyPeerFingerprint(username,expectedFingerprint){const storedFingerprint=this.peerFingerprints.get(username);if(!storedFingerprint){console.warn(`E2EE: No fingerprint for ${username}`);return!1}
const match=storedFingerprint===expectedFingerprint;if(match){this.verifiedPeers.add(username);await this.saveVerifiedPeers();console.log(`âœ“ E2EE: Verified ${username}`)}else{console.error(`âœ— E2EE: Fingerprint mismatch for ${username}`)}
return match},markPeerVerified(username){this.verifiedPeers.add(username);this.autoAcceptedPeers.delete(username);this.saveVerifiedPeers()},markPeerAutoAccepted(username){if(!this.verifiedPeers.has(username)){this.autoAcceptedPeers.add(username);this.saveVerifiedPeers()}},isPeerVerified(username){return this.verifiedPeers.has(username)},isPeerAutoAccepted(username){return this.autoAcceptedPeers.has(username)},async saveVerifiedPeers(){try{const data={verified:Array.from(this.verifiedPeers),autoAccepted:Array.from(this.autoAcceptedPeers)};await this._idbPut('keys','verifiedPeers',data)}catch(err){console.error("E2EE: Failed to save verified peers:",err)}},async loadVerifiedPeers(){try{const data=await this._idbGet('keys','verifiedPeers');if(data){if(data.verified&&Array.isArray(data.verified)){this.verifiedPeers=new Set(data.verified)}
if(data.autoAccepted&&Array.isArray(data.autoAccepted)){this.autoAcceptedPeers=new Set(data.autoAccepted)}}}catch(err){console.error("E2EE: Failed to load verified peers:",err)}},async exportPublicKey(){try{const spki=await crypto.subtle.exportKey("spki",this.keyPair.publicKey);return this.arrayBufferToBase64(spki)}catch(err){console.error("E2EE: Failed to export public key:",err);return null}},async importPublicKey(username,base64){try{const buf=this.base64ToArrayBuffer(base64);const publicKey=await crypto.subtle.importKey("spki",buf,{name:"RSA-OAEP",hash:"SHA-256"},!0,["encrypt"]);this.peerPublicKeys.set(username,publicKey);await this.storePeerFingerprint(username,publicKey);return!0}catch(err){console.error("E2EE: Failed to import public key for",username,err);return!1}},async encryptMessage(message,recipients){try{const aesKey=await crypto.subtle.generateKey({name:"AES-GCM",length:256},!0,["encrypt","decrypt"]);const iv=crypto.getRandomValues(new Uint8Array(12));const enc=new TextEncoder();const encryptedMessage=await crypto.subtle.encrypt({name:"AES-GCM",iv},aesKey,enc.encode(message));const rawAesKey=await crypto.subtle.exportKey("raw",aesKey);const encryptedKeys={};for(const user of recipients){let publicKey=this.peerPublicKeys.get(user);if(!publicKey&&typeof window!=='undefined'&&user===window.E2EE_SELF_USERNAME){publicKey=this.keyPair.publicKey}
if(!publicKey){console.warn(`E2EE: No public key for ${user}`);continue}
try{const encKey=await crypto.subtle.encrypt({name:"RSA-OAEP"},publicKey,rawAesKey);encryptedKeys[user]=this.arrayBufferToBase64(encKey)}catch(err){console.error(`E2EE: RSA encrypt failed for ${user}`,err)}}
return{iv:this.arrayBufferToBase64(iv),encryptedMessage:this.arrayBufferToBase64(encryptedMessage),encryptedKeys,version:'3.0',timestamp:Date.now()}}catch(err){console.error("E2EE: Encryption failed:",err);return null}},recordDecryptionFailure(messageId,error){if(!this.decryptionFailures.has(messageId)){this.decryptionFailures.set(messageId,{attempts:0,lastError:null,timestamp:Date.now()})}
const record=this.decryptionFailures.get(messageId);record.attempts++;record.lastError=error.message;record.timestamp=Date.now()},shouldRetryDecryption(messageId){if(!this.decryptionFailures.has(messageId)){return!0}
const record=this.decryptionFailures.get(messageId);return record.attempts<this.MAX_DECRYPTION_RETRIES},async decryptMessage(encData,encryptedKeyB64,messageId=null){try{if(!encryptedKeyB64){return"[Not encrypted for you]"}
if(messageId&&!this.shouldRetryDecryption(messageId)){const record=this.decryptionFailures.get(messageId);return `[Decryption Failed: ${record.lastError}]`}
const rsaEncrypted=this.base64ToArrayBuffer(encryptedKeyB64);const rawAesKey=await crypto.subtle.decrypt({name:"RSA-OAEP"},this.keyPair.privateKey,rsaEncrypted);const aesKey=await crypto.subtle.importKey("raw",rawAesKey,{name:"AES-GCM",length:256},!1,["decrypt"]);const decrypted=await crypto.subtle.decrypt({name:"AES-GCM",iv:this.base64ToArrayBuffer(encData.iv)},aesKey,this.base64ToArrayBuffer(encData.encryptedMessage));if(messageId)this.decryptionFailures.delete(messageId);return new TextDecoder().decode(decrypted)}catch(err){console.error("E2EE: Decryption failed:",err);if(messageId)this.recordDecryptionFailure(messageId,err);if(err.name==='OperationError'){return"[Decryption Failed: Invalid key or corrupted data]"}else if(err.name==='InvalidAccessError'){return"[Decryption Failed: Access denied]"}else{return `[Decryption Failed: ${err.message}]`}}},arrayBufferToBase64(buffer){const bytes=new Uint8Array(buffer);let binary="";for(let i=0;i<bytes.length;i++){binary+=String.fromCharCode(bytes[i])}
return btoa(binary)},base64ToArrayBuffer(base64){const binary=atob(base64);const bytes=new Uint8Array(binary.length);for(let i=0;i<binary.length;i++){bytes[i]=binary.charCodeAt(i)}
return bytes.buffer},getDebugInfo(){return{hasKeyPair:!!this.keyPair,keyAge:this.keyGenerationDate?Date.now()-this.keyGenerationDate:null,keysExpired:this.keyGenerationDate?this.areKeysExpired(this.keyGenerationDate):null,needsRotation:this.needsKeyRotation(),peerCount:this.peerPublicKeys.size,verifiedPeerCount:this.verifiedPeers.size,failedDecryptions:this.decryptionFailures.size,secureStorage:!0,sessionKeys:this.sessionKeys.size,rotationSchedulerActive:!!this.keyRotationInterval}}};if(typeof module!=="undefined"){module.exports=E2EE}
if(typeof window!=="undefined"){window.E2EE=E2EE}
