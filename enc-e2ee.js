const E2EE={keyPair:null,localMasterKey:null,peerPublicKeys:new Map(),peerFingerprints:new Map(),verifiedPeers:new Set(),autoAcceptedPeers:new Set(),keyGenerationDate:null,decryptionFailures:new Map(),sessionKeys:new Map(),messageStore:new Map(),KEY_EXPIRY_DAYS:30,MAX_DECRYPTION_RETRIES:3,MESSAGE_RETENTION_DAYS:30,KEY_ROTATION_CHECK_INTERVAL:24 * 60 * 60 * 1000,PBKDF2_ITERATIONS:300000,_openIDB(){return new Promise((resolve,reject)=>{if(!('indexedDB' in window))return reject(new Error('indexedDB not supported'));const req=indexedDB.open('e2ee-secure-db',4);req.onupgradeneeded=(e)=>{const db=e.target.result;if(!db.objectStoreNames.contains('keys'))db.createObjectStore('keys');if(!db.objectStoreNames.contains('messages')){const msgStore=db.createObjectStore('messages',{keyPath:'id',autoIncrement:true});msgStore.createIndex('room','room',{unique:false});msgStore.createIndex('timestamp','timestamp',{unique:false});}if(!db.objectStoreNames.contains('roomKeys'))db.createObjectStore('roomKeys');};req.onsuccess=()=> resolve(req.result);req.onerror=()=> reject(req.error);});},async _idbPut(storeName,key,value){const db=await this._openIDB();return new Promise((resolve,reject)=>{const tx=db.transaction([storeName],'readwrite');const store=tx.objectStore(storeName);let req;try{if(storeName==='messages')req=store.add(value);else req=store.put(value,key);}catch(err){db.close();return reject(err);}req.onsuccess=()=>{resolve(req.result);db.close();};req.onerror=()=>{reject(req.error || new Error('IDB put failed'));db.close();};});},async _idbGet(storeName,key){const db=await this._openIDB();return new Promise((resolve,reject)=>{const tx=db.transaction([storeName],'readonly');const store=tx.objectStore(storeName);const r=store.get(key);r.onsuccess=()=>{resolve(r.result);db.close();};r.onerror=()=>{reject(r.error || new Error('IDB get failed'));db.close();};});},async _idbGetAll(storeName,indexName,query){const db=await this._openIDB();return new Promise((resolve,reject)=>{const tx=db.transaction([storeName],'readonly');const store=tx.objectStore(storeName);const index=indexName ? store.index(indexName):store;const r=query ? index.getAll(query):index.getAll();r.onsuccess=()=>{resolve(r.result || []);db.close();};r.onerror=()=>{reject(r.error || new Error('IDB getAll failed'));db.close();};});},async _idbDelete(storeName,key){const db=await this._openIDB();return new Promise((resolve,reject)=>{const tx=db.transaction([storeName],'readwrite');const store=tx.objectStore(storeName);if(key===undefined || key===null){console.warn(`E2EE:Attempting to clear entire store ${storeName}via _idbDelete. Use _idbClear for clarity.`);store.clear();tx.oncomplete=()=>{resolve(true);db.close();};tx.onerror=()=>{reject(tx.error || new Error('IDB clear failed'));db.close();};}else{const r=store.delete(key);r.onsuccess=()=>{resolve(true);db.close();};r.onerror=()=>{reject(r.error || new Error('IDB delete failed'));db.close();};}});},async _idbClear(storeName){const db=await this._openIDB();return new Promise((resolve,reject)=>{const tx=db.transaction([storeName],'readwrite');const store=tx.objectStore(storeName);const r=store.clear();r.onsuccess=()=>{resolve(true);db.close();};r.onerror=()=>{reject(r.error || new Error(`IDB store clear failed for ${storeName}`));db.close();};});},async _getOrCreateLocalMasterKey(){if(this.localMasterKey)return this.localMasterKey;try{const lmk=await this._idbGet('keys','localMasterKey');if(lmk && lmk instanceof CryptoKey && lmk.usages.includes('wrapKey')){this.localMasterKey=lmk;console.log('âœ“ E2EE:Loaded non-exportable Local Master Key(LMK)[AES-KW]');return lmk;}}catch(err){console.warn('E2EE:Failed to load LMK,generating new:',err);}console.log('E2EE:Generating new non-exportable Local Master Key(LMK)[AES-KW]...');const newLmk=await crypto.subtle.generateKey({name:'AES-KW',length:256},false,['wrapKey','unwrapKey']);try{await this._idbPut('keys','localMasterKey',newLmk);this.localMasterKey=newLmk;console.log('âœ“ E2EE:New LMK generated and persisted.');return newLmk;}catch(err){console.error('E2EE:Failed to persist LMK. Keys will be session-only:',err);this.localMasterKey=newLmk;return newLmk;}},async clearLocalMasterKey(){this.localMasterKey=null;try{await this._idbDelete('keys','localMasterKey');}catch(err){console.error('E2EE:Error clearing LMK:',err);}},needsKeyRotation(){if(!this.keyGenerationDate)return false;return this.areKeysExpired(this.keyGenerationDate);},async rotateKeysWithMessages(){console.log('E2EE:Starting key rotation with message re-encryption...');try{const LMK=await this._getOrCreateLocalMasterKey();const allMessages=await this._idbGetAll('messages');const decryptedMessages=new Map();for(const record of allMessages){if(!record.room)continue;try{const roomKeyBundle=this.sessionKeys.get(record.room)|| await this.getOrCreateRoomKey(record.room,'system',LMK);const aesKey=roomKeyBundle.aes;const encrypted=this.base64ToArrayBuffer(record.encrypted);const iv=this.base64ToArrayBuffer(record.iv);const decryptedData=await crypto.subtle.decrypt({name:'AES-GCM',iv},aesKey,encrypted);const decoder=new TextDecoder();const msgData=JSON.parse(decoder.decode(decryptedData));if(!decryptedMessages.has(record.room))decryptedMessages.set(record.room,[]);decryptedMessages.get(record.room).push({...msgData,originalTimestamp:record.timestamp,id:record.id});}catch(err){console.warn(`E2EE:Could not decrypt message ${record.id}during rotation(will skip re-encryption):`,err);}}this.keyPair=await crypto.subtle.generateKey({name:'RSA-OAEP',modulusLength:2048,publicExponent:new Uint8Array([1,0,1]),hash:'SHA-256'},false,['encrypt','decrypt']);this.keyGenerationDate=Date.now();await this.saveKeyPair();console.log('E2EE:New keypair generated and saved');this.sessionKeys.clear();await this._idbClear('roomKeys');console.log('E2EE:Old room keys cleared');await this.clearLocalMasterKey();const newLMK=await this._getOrCreateLocalMasterKey();for(const [room,messages] of decryptedMessages){const newRoomKeyBundle=await this._generateAndPersistRoomKey(room,'system',newLMK);for(const msg of messages){try{if(msg.id)await this._idbDelete('messages',msg.id);const iv=crypto.getRandomValues(new Uint8Array(12));const encoder=new TextEncoder();const msgData=JSON.stringify({content:msg.content,sender:msg.sender,timestamp:msg.timestamp,isOutgoing:msg.isOutgoing});const encrypted=await crypto.subtle.encrypt({name:'AES-GCM',iv},newRoomKeyBundle.aes,encoder.encode(msgData));const hmacSignature=await crypto.subtle.sign('HMAC',newRoomKeyBundle.hmac,encrypted);await this._idbPut('messages',null,{room:room,encrypted:this.arrayBufferToBase64(encrypted),iv:this.arrayBufferToBase64(iv),hmac:this.arrayBufferToBase64(hmacSignature),timestamp:msg.originalTimestamp || Date.now()});}catch(err){console.error('E2EE:Failed to re-encrypt message during rotation:',err);}}}console.log(`âœ“ E2EE:Successfully rotated keys and re-encrypted ${decryptedMessages.size}rooms of messages`);if(typeof window !=='undefined' && window.UIManager)window.UIManager.showNotification('ðŸ”„ Encryption keys rotated successfully. Your messages are secure.','success');if(typeof window !=='undefined' && window.SocketHandler){const newPublicKey=await this.exportPublicKey();if(newPublicKey)window.SocketHandler.broadcastPublicKeyUpdate(newPublicKey);}return true;}catch(err){console.error('E2EE:Key rotation failed:',err);if(typeof window !=='undefined' && window.UIManager)window.UIManager.showNotification('âš ï¸ Key rotation failed. Please try again or contact support.','error');return false;}},async checkAndRotateKeys(){if(this.needsKeyRotation()){console.log('E2EE:Automatic key rotation triggered');return await this.rotateKeysWithMessages();}return false;},startKeyRotationScheduler(){this.checkAndRotateKeys();this.keyRotationInterval=setInterval(()=>{this.checkAndRotateKeys();},this.KEY_ROTATION_CHECK_INTERVAL);console.log('âœ“ E2EE:Key rotation scheduler started');},stopKeyRotationScheduler(){if(this.keyRotationInterval){clearInterval(this.keyRotationInterval);this.keyRotationInterval=null;console.log('E2EE:Key rotation scheduler stopped');}},async rotateRoomKey(roomName,username){console.log(`E2EE:Rotating room key for ${roomName}...`);try{const LMK=await this._getOrCreateLocalMasterKey();const oldBundle=this.sessionKeys.get(roomName)|| await this.getOrCreateRoomKey(roomName,username);const stored=await this._idbGetAll('messages','room',roomName);const decryptedMessages=[];for(const record of stored){try{const encrypted=this.base64ToArrayBuffer(record.encrypted);const iv=this.base64ToArrayBuffer(record.iv);const decrypted=await crypto.subtle.decrypt({name:'AES-GCM',iv},oldBundle.aes,encrypted);const decoder=new TextDecoder();const msgData=JSON.parse(decoder.decode(decrypted));decryptedMessages.push({...msgData,originalTimestamp:record.timestamp,id:record.id});}catch(err){console.warn(`E2EE:Could not decrypt message during room key rotation:`,err);}}const newRoomKeyBundle=await this._generateAndPersistRoomKey(roomName,username,LMK);for(const msg of decryptedMessages){if(msg.id)await this._idbDelete('messages',msg.id);}for(const msg of decryptedMessages){const iv=crypto.getRandomValues(new Uint8Array(12));const encoder=new TextEncoder();const msgData=JSON.stringify({content:msg.content,sender:msg.sender,timestamp:msg.timestamp,isOutgoing:msg.isOutgoing});const encrypted=await crypto.subtle.encrypt({name:'AES-GCM',iv},newRoomKeyBundle.aes,encoder.encode(msgData));const hmacSignature=await crypto.subtle.sign('HMAC',newRoomKeyBundle.hmac,encrypted);await this._idbPut('messages',null,{room:roomName,encrypted:this.arrayBufferToBase64(encrypted),iv:this.arrayBufferToBase64(iv),hmac:this.arrayBufferToBase64(hmacSignature),timestamp:msg.originalTimestamp || Date.now()});}console.log(`âœ“ E2EE:Rotated room key and re-encrypted ${decryptedMessages.length}messages for ${roomName}`);return true;}catch(err){console.error(`E2EE:Room key rotation failed for ${roomName}:`,err);return false;}},async exportMessagesBackup(password){try{const allMessages=await this._idbGetAll('messages');const allRoomKeys={};const LMK=this.localMasterKey || await this._getOrCreateLocalMasterKey();for(const [room,bundle] of this.sessionKeys){try{const rawAes=await crypto.subtle.exportKey('raw',bundle.aes);const wrappedAes=await crypto.subtle.wrapKey('raw',bundle.aes,LMK,'AES-KW');const wrappedHmac=await crypto.subtle.wrapKey('raw',bundle.hmac,LMK,'AES-KW');allRoomKeys[room]={wrappedAes:this.arrayBufferToBase64(wrappedAes),wrappedHmac:this.arrayBufferToBase64(wrappedHmac)};}catch(e){console.warn('E2EE:Could not wrap room key for backup(skipping):',room,e);}}const backupData={version:'4.0',timestamp:Date.now(),messages:allMessages,wrappedRoomKeys:allRoomKeys,verifiedPeers:Array.from(this.verifiedPeers)};const encoder=new TextEncoder();const salt=crypto.getRandomValues(new Uint8Array(16));const pwKey=await crypto.subtle.importKey('raw',encoder.encode(password),{name:'PBKDF2'},false,['deriveKey']);const aesKey=await crypto.subtle.deriveKey({name:'PBKDF2',salt,iterations:this.PBKDF2_ITERATIONS,hash:'SHA-256'},pwKey,{name:'AES-GCM',length:256},false,['encrypt']);const iv=crypto.getRandomValues(new Uint8Array(12));const encrypted=await crypto.subtle.encrypt({name:'AES-GCM',iv},aesKey,encoder.encode(JSON.stringify(backupData)));return{version:'4.0',salt:this.arrayBufferToBase64(salt),iv:this.arrayBufferToBase64(iv),data:this.arrayBufferToBase64(encrypted),timestamp:Date.now()};}catch(err){console.error('E2EE:Backup export failed:',err);return null;}},async importMessagesBackup(encryptedBackup,password){try{const encoder=new TextEncoder();const decoder=new TextDecoder();const LMK=await this._getOrCreateLocalMasterKey();const pwKey=await crypto.subtle.importKey('raw',encoder.encode(password),{name:'PBKDF2'},false,['deriveKey']);const salt=this.base64ToArrayBuffer(encryptedBackup.salt);const aesKey=await crypto.subtle.deriveKey({name:'PBKDF2',salt,iterations:this.PBKDF2_ITERATIONS,hash:'SHA-256'},pwKey,{name:'AES-GCM',length:256},false,['decrypt']);const iv=this.base64ToArrayBuffer(encryptedBackup.iv);const encryptedData=this.base64ToArrayBuffer(encryptedBackup.data);const decrypted=await crypto.subtle.decrypt({name:'AES-GCM',iv},aesKey,encryptedData);const backupData=JSON.parse(decoder.decode(decrypted));for(const [room,keyObj] of Object.entries(backupData.wrappedRoomKeys ||{})){try{const wrappedAes=this.base64ToArrayBuffer(keyObj.wrappedAes);const wrappedHmac=this.base64ToArrayBuffer(keyObj.wrappedHmac);const roomAes=await crypto.subtle.unwrapKey('raw',wrappedAes,LMK,'AES-KW',{name:'AES-GCM',length:256},true,['encrypt','decrypt']);const roomHmac=await crypto.subtle.unwrapKey('raw',wrappedHmac,LMK,'AES-KW',{name:'HMAC',hash:'SHA-256'},true,['sign','verify']);this.sessionKeys.set(room,{aes:roomAes,hmac:roomHmac});await this._idbPut('roomKeys',room,{wrappedAes:keyObj.wrappedAes,wrappedHmac:keyObj.wrappedHmac,created:Date.now(),restored:true});}catch(e){console.warn('E2EE:Could not import or unwrap room key from backup:',room,e);}}for(const msg of backupData.messages || []){await this._idbPut('messages',null,msg);}if(backupData.verifiedPeers){this.verifiedPeers=new Set(backupData.verifiedPeers);await this.saveVerifiedPeers();}console.log(`âœ“ E2EE:Restored ${(backupData.messages||[]).length}messages from backup`);return true;}catch(err){console.error('E2EE:Backup import failed:',err);return false;}},async deriveStorageKey(username,seed){const encoder=new TextEncoder();const pwKey=await crypto.subtle.importKey('raw',encoder.encode(username + '|' + seed),{name:'PBKDF2'},false,['deriveKey']);const salt=encoder.encode('e2ee-storage-salt-v1');return await crypto.subtle.deriveKey({name:'PBKDF2',salt,iterations:this.PBKDF2_ITERATIONS,hash:'SHA-256'},pwKey,{name:'AES-GCM',length:256},false,['encrypt','decrypt']);},async saveKeyPair(){try{const spki=await crypto.subtle.exportKey('spki',this.keyPair.publicKey);const publicKeyB64=this.arrayBufferToBase64(spki);this.keyGenerationDate=this.keyGenerationDate || Date.now();try{await this._idbPut('keys','privateKey',this.keyPair.privateKey);await this._idbPut('keys','publicKey',publicKeyB64);await this._idbPut('keys','meta',{createdAt:this.keyGenerationDate,version:'4.0',type:'non-exportable'});console.log('âœ“ E2EE:Private key persisted securely in IndexedDB(structured clone)');return true;}catch(err){await this._idbPut('keys','publicKey',publicKeyB64).catch(()=>{});await this._idbPut('keys','meta',{createdAt:this.keyGenerationDate,version:'4.0',type:'session-only'}).catch(()=>{});console.warn('âš  E2EE:IndexedDB persistence failed for private key. Keys will be session-only.',err);return false;}}catch(err){console.warn('âš  E2EE:saveKeyPair error:',err);return false;}},async loadKeyPair(){try{const priKey=await this._idbGet('keys','privateKey');const pubKeyB64=await this._idbGet('keys','publicKey');const meta=await this._idbGet('keys','meta');if(!priKey || !pubKeyB64){console.log('E2EE:No persisted keys found');return false;}if(priKey && priKey instanceof CryptoKey && priKey.usages.includes('decrypt')){const pubBuf=this.base64ToArrayBuffer(pubKeyB64);const pubKey=await crypto.subtle.importKey('spki',pubBuf,{name:'RSA-OAEP',hash:'SHA-256'},true,['encrypt']);this.keyPair={publicKey:pubKey,privateKey:priKey};this.keyGenerationDate=(meta && meta.createdAt)? meta.createdAt:Date.now();if(this.areKeysExpired(this.keyGenerationDate)){console.warn('âš  E2EE:Keys expired,regeneration recommended');this.showKeyExpiryWarning();}console.log('âœ“ E2EE:Loaded non-exportable keys from IndexedDB');return true;}console.log('E2EE:Private key in storage is not a CryptoKey â€” treating as absent');return false;}catch(err){console.error('E2EE:Failed to load keys:',err);return false;}},areKeysExpired(createdAt){if(!createdAt)return false;const age=Date.now()- createdAt;const expiryMs=this.KEY_EXPIRY_DAYS * 24 * 60 * 60 * 1000;return age > expiryMs;},showKeyExpiryWarning(){if(typeof window !=='undefined' && window.UIManager)window.UIManager.showNotification('âš ï¸ Your encryption keys are older than 30 days. Consider regenerating for better security.','warning');},async init(){const loaded=await this.loadKeyPair();await this.loadVerifiedPeers();await this._getOrCreateLocalMasterKey();if(loaded){this.startKeyRotationScheduler();return true;}console.log('E2EE:Generating new RSA key pair(non-exportable)...');this.keyPair=await crypto.subtle.generateKey({name:'RSA-OAEP',modulusLength:2048,publicExponent:new Uint8Array([1,0,1]),hash:'SHA-256'},false,['encrypt','decrypt']);this.keyGenerationDate=Date.now();await this.saveKeyPair();console.log('âœ“ E2EE:New key pair created');this.startKeyRotationScheduler();return true;},async rotateKeys(){console.log('E2EE:Manual key rotation requested...');return await this.rotateKeysWithMessages();},async clearKeys(){this.stopKeyRotationScheduler();this.keyPair=null;this.localMasterKey=null;this.peerPublicKeys.clear();this.peerFingerprints.clear();this.verifiedPeers.clear();this.keyGenerationDate=null;this.decryptionFailures.clear();this.sessionKeys.clear();this.messageStore.clear();try{await this._idbDelete('keys','privateKey');await this._idbDelete('keys','publicKey');await this._idbDelete('keys','meta');await this._idbDelete('keys','verifiedPeers');await this._idbDelete('keys','localMasterKey');await this._idbClear('roomKeys');}catch(err){console.error('E2EE:Error clearing keys:',err);}console.log('âœ“ E2EE:All keys cleared');},async _generateAndPersistRoomKey(roomName,username,LMK){const roomAes=await crypto.subtle.generateKey({name:'AES-GCM',length:256},false,['encrypt','decrypt']);const roomHmac=await crypto.subtle.generateKey({name:'HMAC',hash:'SHA-256'},false,['sign','verify']);const bundle={aes:roomAes,hmac:roomHmac};try{const wrappedAes=await crypto.subtle.wrapKey('raw',roomAes,LMK,'AES-KW');const wrappedHmac=await crypto.subtle.wrapKey('raw',roomHmac,LMK,'AES-KW');await this._idbPut('roomKeys',roomName,{wrappedAes:this.arrayBufferToBase64(wrappedAes),wrappedHmac:this.arrayBufferToBase64(wrappedHmac),created:Date.now(),username});this.sessionKeys.set(roomName,bundle);}catch(err){console.warn('E2EE:Could not persist wrapped room key. Key is session-only:',err);this.sessionKeys.set(roomName,bundle);}return bundle;},async getOrCreateRoomKey(roomName,username){if(this.sessionKeys.has(roomName))return this.sessionKeys.get(roomName);const LMK=await this._getOrCreateLocalMasterKey();try{const stored=await this._idbGet('roomKeys',roomName);if(stored && stored.wrappedAes){const wrappedAes=this.base64ToArrayBuffer(stored.wrappedAes);const wrappedHmac=this.base64ToArrayBuffer(stored.wrappedHmac);const roomAes=await crypto.subtle.unwrapKey('raw',wrappedAes,LMK,'AES-KW',{name:'AES-GCM',length:256},true,['encrypt','decrypt','wrapKey','unwrapKey']);const roomHmac=await crypto.subtle.unwrapKey('raw',wrappedHmac,LMK,'AES-KW',{name:'HMAC',hash:'SHA-256'},true,['sign','verify']);const bundle={aes:roomAes,hmac:roomHmac};this.sessionKeys.set(roomName,bundle);console.log(`âœ“ E2EE:Loaded LMK-wrapped room key for ${roomName}`);return bundle;}else if(stored && stored.key){console.warn(`E2EE:Found legacy raw room key for ${roomName}. Migrating to LMK-wrapped format.`);const key=await crypto.subtle.importKey('raw',this.base64ToArrayBuffer(stored.key),{name:'AES-GCM',length:256},true,['encrypt','decrypt','wrapKey','unwrapKey']);const hmac=stored.hmac ? await crypto.subtle.importKey('raw',this.base64ToArrayBuffer(stored.hmac),{name:'HMAC',hash:'SHA-256'},true,['sign','verify']):null;const bundle={aes:key,hmac};this.sessionKeys.set(roomName,bundle);await this._generateAndPersistRoomKey(roomName,username,LMK);await this._idbDelete('roomKeys',roomName);return bundle;}}catch(err){console.warn('E2EE:Could not load or unwrap room key,generating new:',err);}return await this._generateAndPersistRoomKey(roomName,username,LMK);},async storeMessage(roomName,message,isOutgoing,username){try{const bundle=await this.getOrCreateRoomKey(roomName,username);const iv=crypto.getRandomValues(new Uint8Array(12));const encoder=new TextEncoder();const msgData=JSON.stringify({content:message.content || message.message,sender:message.sender || message.username,timestamp:message.timestamp || Date.now(),isOutgoing:isOutgoing});const aad=encoder.encode(`${roomName}|${msgData.sender}|${msgData.timestamp}`);const encrypted=await crypto.subtle.encrypt({name:'AES-GCM',iv,additionalData:aad},bundle.aes,encoder.encode(msgData));const hmacInput=new Uint8Array(encrypted.byteLength + aad.byteLength);hmacInput.set(new Uint8Array(encrypted),0);hmacInput.set(aad,encrypted.byteLength);const hmacSignature=await crypto.subtle.sign('HMAC',bundle.hmac,hmacInput);await this._idbPut('messages',null,{room:roomName,encrypted:this.arrayBufferToBase64(encrypted),iv:this.arrayBufferToBase64(iv),hmac:this.arrayBufferToBase64(hmacSignature),timestamp:msgData.timestamp});console.log('âœ“ E2EE:Message stored securely with mandatory HMAC and AAD');}catch(err){console.error('E2EE:Failed to store message:',err);}},async loadMessages(roomName,username){try{const bundle=await this.getOrCreateRoomKey(roomName,username);const stored=await this._idbGetAll('messages','room',roomName);const messages=[];const decoder=new TextDecoder();const encoder=new TextEncoder();for(const record of stored){try{const encrypted=this.base64ToArrayBuffer(record.encrypted);const iv=this.base64ToArrayBuffer(record.iv);const hmac=this.base64ToArrayBuffer(record.hmac);const temp=JSON.parse(decoder.decode(await crypto.subtle.decrypt({name:'AES-GCM',iv},bundle.aes,encrypted))).sender;const aad=encoder.encode(`${roomName}|${temp}|${record.timestamp}`);const hmacInput=new Uint8Array(encrypted.byteLength + aad.byteLength);hmacInput.set(new Uint8Array(encrypted),0);hmacInput.set(aad,encrypted.byteLength);const validHmac=await crypto.subtle.verify('HMAC',bundle.hmac,hmac,hmacInput);if(!validHmac){console.warn(`E2EE:HMAC verification failed for message in room ${roomName}. Skipping message.`);continue;}const decrypted=await crypto.subtle.decrypt({name:'AES-GCM',iv,additionalData:aad},bundle.aes,encrypted);const msgData=JSON.parse(decoder.decode(decrypted));messages.push(msgData);}catch(err){console.warn('E2EE:Could not decrypt message(HMAC failure or corruption):',err);}}messages.sort((a,b)=> a.timestamp - b.timestamp);console.log(`âœ“ E2EE:Loaded ${messages.length}verified messages for ${roomName}`);return messages;}catch(err){console.error('E2EE:Failed to load messages:',err);return [];}},async clearOldMessages(){try{const cutoff=Date.now()-(this.MESSAGE_RETENTION_DAYS * 24 * 60 * 60 * 1000);const db=await this._openIDB();const tx=db.transaction(['messages'],'readwrite');const store=tx.objectStore('messages');const index=store.index('timestamp');const range=IDBKeyRange.upperBound(cutoff);let deleted=0;const request=index.openCursor(range);await new Promise((resolve,reject)=>{request.onsuccess=(e)=>{const cursor=e.target.result;if(cursor){cursor.delete();deleted++;cursor.continue();}else{resolve();}};request.onerror=()=> reject(request.error);});db.close();console.log(`âœ“ E2EE:Deleted ${deleted}old messages`);}catch(err){console.error('E2EE:Failed to clear old messages:',err);}},async getPublicKeyFingerprint(publicKey=null){try{const key=publicKey || this.keyPair.publicKey;const spki=await crypto.subtle.exportKey('spki',key);const hash=await crypto.subtle.digest('SHA-256',spki);const fingerprint=Array.from(new Uint8Array(hash)).map(x=> x.toString(16).padStart(2,'0')).join('');return fingerprint.match(/.{1,4}/g).join(' ').toUpperCase().substring(0,47);}catch(err){console.error('E2EE:Failed to generate fingerprint:',err);return null;}},async getShortFingerprint(publicKey=null){const full=await this.getPublicKeyFingerprint(publicKey);if(!full)return null;return full.split(' ').slice(0,6).join(' ');},async storePeerFingerprint(username,publicKey){const fingerprint=await this.getPublicKeyFingerprint(publicKey);if(fingerprint)this.peerFingerprints.set(username,fingerprint);},async verifyShortCode(username,expectedShortCode){const storedFingerprint=this.peerFingerprints.get(username);if(!storedFingerprint){console.warn(`E2EE:No fingerprint for ${username}to compare.`);return false;}const storedShortCode=storedFingerprint.split(' ').slice(0,6).join(' ').toUpperCase();const expectedUpper=expectedShortCode.trim().toUpperCase();const match=storedShortCode===expectedUpper;if(match){this.verifiedPeers.add(username);await this.saveVerifiedPeers();console.log(`âœ“ E2EE:Verified ${username}via short code match`);}else{console.error(`âœ— E2EE:Short code mismatch for ${username}. Expected:${storedShortCode},Got:${expectedUpper}`);}return match;},async verifyPeerFingerprint(username,expectedFingerprint){const storedFingerprint=this.peerFingerprints.get(username);if(!storedFingerprint){console.warn(`E2EE:No fingerprint for ${username}`);return false;}const match=storedFingerprint===expectedFingerprint;if(match){this.verifiedPeers.add(username);await this.saveVerifiedPeers();console.log(`âœ“ E2EE:Verified ${username}`);}else{console.error(`âœ— E2EE:Fingerprint mismatch for ${username}`);}return match;},markPeerVerified(username){this.verifiedPeers.add(username);this.autoAcceptedPeers.delete(username);this.saveVerifiedPeers();},markPeerAutoAccepted(username){if(!this.verifiedPeers.has(username)){this.autoAcceptedPeers.add(username);this.saveVerifiedPeers();}},isPeerVerified(username){return this.verifiedPeers.has(username);},isPeerAutoAccepted(username){return this.autoAcceptedPeers.has(username);},async saveVerifiedPeers(){try{const data={verified:Array.from(this.verifiedPeers),autoAccepted:Array.from(this.autoAcceptedPeers)};await this._idbPut('keys','verifiedPeers',data);}catch(err){console.error('E2EE:Failed to save verified peers:',err);}},async loadVerifiedPeers(){try{const data=await this._idbGet('keys','verifiedPeers');if(data){if(data.verified && Array.isArray(data.verified))this.verifiedPeers=new Set(data.verified);if(data.autoAccepted && Array.isArray(data.autoAccepted))this.autoAcceptedPeers=new Set(data.autoAccepted);}}catch(err){console.error('E2EE:Failed to load verified peers:',err);}},async exportPublicKey(){try{const spki=await crypto.subtle.exportKey('spki',this.keyPair.publicKey);return this.arrayBufferToBase64(spki);}catch(err){console.error('E2EE:Failed to export public key:',err);return null;}},async importPublicKey(username,base64){try{const buf=this.base64ToArrayBuffer(base64);const publicKey=await crypto.subtle.importKey('spki',buf,{name:'RSA-OAEP',hash:'SHA-256'},true,['encrypt']);this.peerPublicKeys.set(username,publicKey);await this.storePeerFingerprint(username,publicKey);return true;}catch(err){console.error('E2EE:Failed to import public key for',username,err);return false;}},async encryptMessage(message,recipients){try{const aesKey=await crypto.subtle.generateKey({name:'AES-GCM',length:256},true,['encrypt','decrypt']);const iv=crypto.getRandomValues(new Uint8Array(12));const enc=new TextEncoder();const encryptedMessage=await crypto.subtle.encrypt({name:'AES-GCM',iv},aesKey,enc.encode(message));const rawAesKey=await crypto.subtle.exportKey('raw',aesKey);const encryptedKeys={};for(const user of recipients){let publicKey=this.peerPublicKeys.get(user);if(!publicKey && typeof window !=='undefined' && user===window.E2EE_SELF_USERNAME)publicKey=this.keyPair.publicKey;if(!publicKey){console.warn(`E2EE:No public key for ${user}`);continue;}try{const encKey=await crypto.subtle.encrypt({name:'RSA-OAEP'},publicKey,rawAesKey);encryptedKeys[user]=this.arrayBufferToBase64(encKey);}catch(err){console.error(`E2EE:RSA encrypt failed for ${user}`,err);}}return{iv:this.arrayBufferToBase64(iv),encryptedMessage:this.arrayBufferToBase64(encryptedMessage),encryptedKeys,version:'4.0',timestamp:Date.now()};}catch(err){console.error('E2EE:Encryption failed:',err);return null;}},recordDecryptionFailure(messageId,error){if(!this.decryptionFailures.has(messageId))this.decryptionFailures.set(messageId,{attempts:0,lastError:null,timestamp:Date.now()});const record=this.decryptionFailures.get(messageId);record.attempts++;record.lastError=error.message;record.timestamp=Date.now();},shouldRetryDecryption(messageId){if(!this.decryptionFailures.has(messageId))return true;const record=this.decryptionFailures.get(messageId);return record.attempts < this.MAX_DECRYPTION_RETRIES;},async decryptMessage(encData,encryptedKeyB64,messageId=null){try{if(!encryptedKeyB64)return '[Not encrypted for you]';if(messageId && !this.shouldRetryDecryption(messageId)){const record=this.decryptionFailures.get(messageId);return `[Decryption Failed:${record.lastError}]`;}const rsaEncrypted=this.base64ToArrayBuffer(encryptedKeyB64);const rawAesKey=await crypto.subtle.decrypt({name:'RSA-OAEP'},this.keyPair.privateKey,rsaEncrypted);const aesKey=await crypto.subtle.importKey('raw',rawAesKey,{name:'AES-GCM',length:256},false,['decrypt']);const decrypted=await crypto.subtle.decrypt({name:'AES-GCM',iv:this.base64ToArrayBuffer(encData.iv)},aesKey,this.base64ToArrayBuffer(encData.encryptedMessage));if(messageId)this.decryptionFailures.delete(messageId);return new TextDecoder().decode(decrypted);}catch(err){console.error('E2EE:Decryption failed:',err);if(messageId)this.recordDecryptionFailure(messageId,err);if(err.name==='OperationError')return '[Decryption Failed:Invalid key or corrupted data]';if(err.name==='InvalidAccessError')return '[Decryption Failed:Access denied]';return `[Decryption Failed:${err.message}]`;}},arrayBufferToBase64(buffer){const bytes=new Uint8Array(buffer);let binary='';for(let i=0;i < bytes.length;i++)binary +=String.fromCharCode(bytes[i]);return btoa(binary);},base64ToArrayBuffer(base64){const binary=atob(base64);const bytes=new Uint8Array(binary.length);for(let i=0;i < binary.length;i++)bytes[i]=binary.charCodeAt(i);return bytes.buffer;},getDebugInfo(){return{hasKeyPair:!!this.keyPair,hasLMK:!!this.localMasterKey,keyAge:this.keyGenerationDate ? Date.now()- this.keyGenerationDate:null,keysExpired:this.keyGenerationDate ? this.areKeysExpired(this.keyGenerationDate):null,needsRotation:this.needsKeyRotation(),peerCount:this.peerPublicKeys.size,verifiedPeerCount:this.verifiedPeers.size,failedDecryptions:this.decryptionFailures.size,secureStorage:true,sessionKeys:this.sessionKeys.size,rotationSchedulerActive:!!this.keyRotationInterval,PBKDF2_ITERATIONS:this.PBKDF2_ITERATIONS,version:'4.0-patched'};}};if(typeof module !=='undefined')module.exports=E2EE;if(typeof window !=='undefined')window.E2EE=E2EE;
