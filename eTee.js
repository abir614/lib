const E2EE={keyPair:null,localMasterKey:null,peerPublicKeys:new Map,peerFingerprints:new Map,verifiedPeers:new Set,autoAcceptedPeers:new Set,secureUsers:new Set,roomSecurityMode:new Map,keyGenerationDate:null,decryptionFailures:new Map,sessionKeys:new Map,messageStore:new Map,KEY_EXPIRY_DAYS:30,MAX_DECRYPTION_RETRIES:3,MESSAGE_RETENTION_DAYS:30,KEY_ROTATION_CHECK_INTERVAL:864e5,PBKDF2_ITERATIONS:3e5,_openIDB:()=>new Promise(((e,t)=>{if(!("indexedDB"in window))return t(new Error("indexedDB not supported"));const r=indexedDB.open("e2ee-secure-db",4);r.onupgradeneeded=e=>{const t=e.target.result;if(t.objectStoreNames.contains("keys")||t.createObjectStore("keys"),!t.objectStoreNames.contains("messages")){const e=t.createObjectStore("messages",{keyPath:"id",autoIncrement:!0});e.createIndex("room","room",{unique:!1}),e.createIndex("timestamp","timestamp",{unique:!1})}t.objectStoreNames.contains("roomKeys")||t.createObjectStore("roomKeys")},r.onsuccess=()=>e(r.result),r.onerror=()=>t(r.error)})),async _idbPut(e,t,r){const s=await this._openIDB();return new Promise(((a,o)=>{const i=s.transaction([e],"readwrite").objectStore(e);let n;try{n="messages"===e?i.add(r):i.put(r,t)}catch(e){return s.close(),o(e)}n.onsuccess=()=>{a(n.result),s.close()},n.onerror=()=>{o(n.error||new Error("IDB put failed")),s.close()}}))},async _idbGet(e,t){const r=await this._openIDB();return new Promise(((s,a)=>{const o=r.transaction([e],"readonly").objectStore(e).get(t);o.onsuccess=()=>{s(o.result),r.close()},o.onerror=()=>{a(o.error||new Error("IDB get failed")),r.close()}}))},async _idbGetAll(e,t,r){const s=await this._openIDB();return new Promise(((a,o)=>{const i=s.transaction([e],"readonly").objectStore(e),n=t?i.index(t):i,c=r?n.getAll(r):n.getAll();c.onsuccess=()=>{a(c.result||[]),s.close()},c.onerror=()=>{o(c.error||new Error("IDB getAll failed")),s.close()}}))},async _idbDelete(e,t){const r=await this._openIDB();return new Promise(((s,a)=>{const o=r.transaction([e],"readwrite"),i=o.objectStore(e);if(null==t)console.warn(`E2EE:Attempting to clear entire store ${e}via _idbDelete. Use _idbClear for clarity.`),i.clear(),o.oncomplete=()=>{s(!0),r.close()},o.onerror=()=>{a(o.error||new Error("IDB clear failed")),r.close()};else{const e=i.delete(t);e.onsuccess=()=>{s(!0),r.close()},e.onerror=()=>{a(e.error||new Error("IDB delete failed")),r.close()}}}))},async _idbClear(e){const t=await this._openIDB();return new Promise(((r,s)=>{const a=t.transaction([e],"readwrite").objectStore(e).clear();a.onsuccess=()=>{r(!0),t.close()},a.onerror=()=>{s(a.error||new Error(`IDB store clear failed for ${e}`)),t.close()}}))},async _getOrCreateLocalMasterKey(){if(this.localMasterKey)return this.localMasterKey;try{const e=await this._idbGet("keys","localMasterKey");if(e&&e instanceof CryptoKey&&e.usages.includes("wrapKey"))return this.localMasterKey=e,console.log("âœ“ E2EE:Loaded non-exportable Local Master Key(LMK)[AES-KW]"),e}catch(e){console.warn("E2EE:Failed to load LMK,generating new:",e)}console.log("E2EE:Generating new non-exportable Local Master Key(LMK)[AES-KW]...");const e=await crypto.subtle.generateKey({name:"AES-KW",length:256},!1,["wrapKey","unwrapKey"]);try{return await this._idbPut("keys","localMasterKey",e),this.localMasterKey=e,console.log("âœ“ E2EE:New LMK generated and persisted."),e}catch(t){return console.error("E2EE:Failed to persist LMK. Keys will be session-only:",t),this.localMasterKey=e,e}},async clearLocalMasterKey(){this.localMasterKey=null;try{await this._idbDelete("keys","localMasterKey")}catch(e){console.error("E2EE:Error clearing LMK:",e)}},needsKeyRotation(){return!!this.keyGenerationDate&&this.areKeysExpired(this.keyGenerationDate)},async rotateKeysWithMessages(){console.log("E2EE:Starting key rotation with message re-encryption...");try{const e=await this._getOrCreateLocalMasterKey(),t=await this._idbGetAll("messages"),r=new Map;for(const s of t)if(s.room)try{const t=(this.sessionKeys.get(s.room)||await this.getOrCreateRoomKey(s.room,"system",e)).aes,a=this.base64ToArrayBuffer(s.encrypted),o=this.base64ToArrayBuffer(s.iv),i=await crypto.subtle.decrypt({name:"AES-GCM",iv:o},t,a),n=new TextDecoder,c=JSON.parse(n.decode(i));r.has(s.room)||r.set(s.room,[]),r.get(s.room).push({...c,originalTimestamp:s.timestamp,id:s.id})}catch(e){console.warn(`E2EE:Could not decrypt message ${s.id}during rotation(will skip re-encryption):`,e)}this.keyPair=await crypto.subtle.generateKey({name:"RSA-OAEP",modulusLength:2048,publicExponent:new Uint8Array([1,0,1]),hash:"SHA-256"},!1,["encrypt","decrypt"]),this.keyGenerationDate=Date.now(),await this.saveKeyPair(),console.log("E2EE:New keypair generated and saved"),this.sessionKeys.clear(),await this._idbClear("roomKeys"),console.log("E2EE:Old room keys cleared"),await this.clearLocalMasterKey();const s=await this._getOrCreateLocalMasterKey();for(const[e,t]of r){const r=await this._generateAndPersistRoomKey(e,"system",s);for(const s of t)try{s.id&&await this._idbDelete("messages",s.id);const t=crypto.getRandomValues(new Uint8Array(12)),a=new TextEncoder,o=JSON.stringify({content:s.content,sender:s.sender,timestamp:s.timestamp,isOutgoing:s.isOutgoing}),i=await crypto.subtle.encrypt({name:"AES-GCM",iv:t},r.aes,a.encode(o)),n=await crypto.subtle.sign("HMAC",r.hmac,i);await this._idbPut("messages",null,{room:e,encrypted:this.arrayBufferToBase64(i),iv:this.arrayBufferToBase64(t),hmac:this.arrayBufferToBase64(n),timestamp:s.originalTimestamp||Date.now()})}catch(e){console.error("E2EE:Failed to re-encrypt message during rotation:",e)}}if(console.log(`âœ“ E2EE:Successfully rotated keys and re-encrypted ${r.size}rooms of messages`),"undefined"!=typeof window&&window.UIManager&&window.UIManager.showNotification("ðŸ”„ Encryption keys rotated successfully. Your messages are secure.","success"),"undefined"!=typeof window&&window.SocketHandler){const e=await this.exportPublicKey();e&&window.SocketHandler.broadcastPublicKeyUpdate(e)}return!0}catch(e){return console.error("E2EE:Key rotation failed:",e),"undefined"!=typeof window&&window.UIManager&&window.UIManager.showNotification("âš ï¸ Key rotation failed. Please try again or contact support.","error"),!1}},async checkAndRotateKeys(){return!!this.needsKeyRotation()&&(console.log("E2EE:Automatic key rotation triggered"),await this.rotateKeysWithMessages())},startKeyRotationScheduler(){this.checkAndRotateKeys(),this.keyRotationInterval=setInterval((()=>{this.checkAndRotateKeys()}),this.KEY_ROTATION_CHECK_INTERVAL),console.log("âœ“ E2EE:Key rotation scheduler started")},stopKeyRotationScheduler(){this.keyRotationInterval&&(clearInterval(this.keyRotationInterval),this.keyRotationInterval=null,console.log("E2EE:Key rotation scheduler stopped"))},async rotateRoomKey(e,t){console.log(`E2EE:Rotating room key for ${e}...`);try{const r=await this._getOrCreateLocalMasterKey(),s=this.sessionKeys.get(e)||await this.getOrCreateRoomKey(e,t),a=await this._idbGetAll("messages","room",e),o=[];for(const e of a)try{const t=this.base64ToArrayBuffer(e.encrypted),r=this.base64ToArrayBuffer(e.iv),a=await crypto.subtle.decrypt({name:"AES-GCM",iv:r},s.aes,t),i=new TextDecoder,n=JSON.parse(i.decode(a));o.push({...n,originalTimestamp:e.timestamp,id:e.id})}catch(e){console.warn("E2EE:Could not decrypt message during room key rotation:",e)}const i=await this._generateAndPersistRoomKey(e,t,r);for(const e of o)e.id&&await this._idbDelete("messages",e.id);for(const t of o){const r=crypto.getRandomValues(new Uint8Array(12)),s=new TextEncoder,a=JSON.stringify({content:t.content,sender:t.sender,timestamp:t.timestamp,isOutgoing:t.isOutgoing}),o=await crypto.subtle.encrypt({name:"AES-GCM",iv:r},i.aes,s.encode(a)),n=await crypto.subtle.sign("HMAC",i.hmac,o);await this._idbPut("messages",null,{room:e,encrypted:this.arrayBufferToBase64(o),iv:this.arrayBufferToBase64(r),hmac:this.arrayBufferToBase64(n),timestamp:t.originalTimestamp||Date.now()})}return console.log(`âœ“ E2EE:Rotated room key and re-encrypted ${o.length}messages for ${e}`),!0}catch(t){return console.error(`E2EE:Room key rotation failed for ${e}:`,t),!1}},async exportMessagesBackup(e){try{const t=await this._idbGetAll("messages"),r={},s=this.localMasterKey||await this._getOrCreateLocalMasterKey();for(const[e,t]of this.sessionKeys)try{await crypto.subtle.exportKey("raw",t.aes);const a=await crypto.subtle.wrapKey("raw",t.aes,s,"AES-KW"),o=await crypto.subtle.wrapKey("raw",t.hmac,s,"AES-KW");r[e]={wrappedAes:this.arrayBufferToBase64(a),wrappedHmac:this.arrayBufferToBase64(o)}}catch(t){console.warn("E2EE:Could not wrap room key for backup(skipping):",e,t)}const a={version:"4.0",timestamp:Date.now(),messages:t,wrappedRoomKeys:r,verifiedPeers:Array.from(this.verifiedPeers)},o=new TextEncoder,i=crypto.getRandomValues(new Uint8Array(16)),n=await crypto.subtle.importKey("raw",o.encode(e),{name:"PBKDF2"},!1,["deriveKey"]),c=await crypto.subtle.deriveKey({name:"PBKDF2",salt:i,iterations:this.PBKDF2_ITERATIONS,hash:"SHA-256"},n,{name:"AES-GCM",length:256},!1,["encrypt"]),y=crypto.getRandomValues(new Uint8Array(12)),l=await crypto.subtle.encrypt({name:"AES-GCM",iv:y},c,o.encode(JSON.stringify(a)));return{version:"4.0",salt:this.arrayBufferToBase64(i),iv:this.arrayBufferToBase64(y),data:this.arrayBufferToBase64(l),timestamp:Date.now()}}catch(e){return console.error("E2EE:Backup export failed:",e),null}},async importMessagesBackup(e,t){try{const r=new TextEncoder,s=new TextDecoder,a=await this._getOrCreateLocalMasterKey(),o=await crypto.subtle.importKey("raw",r.encode(t),{name:"PBKDF2"},!1,["deriveKey"]),i=this.base64ToArrayBuffer(e.salt),n=await crypto.subtle.deriveKey({name:"PBKDF2",salt:i,iterations:this.PBKDF2_ITERATIONS,hash:"SHA-256"},o,{name:"AES-GCM",length:256},!1,["decrypt"]),c=this.base64ToArrayBuffer(e.iv),y=this.base64ToArrayBuffer(e.data),l=await crypto.subtle.decrypt({name:"AES-GCM",iv:c},n,y),d=JSON.parse(s.decode(l));for(const[e,t]of Object.entries(d.wrappedRoomKeys||{}))try{const r=this.base64ToArrayBuffer(t.wrappedAes),s=this.base64ToArrayBuffer(t.wrappedHmac),o=await crypto.subtle.unwrapKey("raw",r,a,"AES-KW",{name:"AES-GCM",length:256},!0,["encrypt","decrypt"]),i=await crypto.subtle.unwrapKey("raw",s,a,"AES-KW",{name:"HMAC",hash:"SHA-256"},!0,["sign","verify"]);this.sessionKeys.set(e,{aes:o,hmac:i}),await this._idbPut("roomKeys",e,{wrappedAes:t.wrappedAes,wrappedHmac:t.wrappedHmac,created:Date.now(),restored:!0})}catch(t){console.warn("E2EE:Could not import or unwrap room key from backup:",e,t)}for(const e of d.messages||[])await this._idbPut("messages",null,e);return d.verifiedPeers&&(this.verifiedPeers=new Set(d.verifiedPeers),await this.saveVerifiedPeers()),console.log(`âœ“ E2EE:Restored ${(d.messages||[]).length}messages from backup`),!0}catch(e){return console.error("E2EE:Backup import failed:",e),!1}},async deriveStorageKey(e,t){const r=new TextEncoder,s=await crypto.subtle.importKey("raw",r.encode(e+"|"+t),{name:"PBKDF2"},!1,["deriveKey"]),a=r.encode("e2ee-storage-salt-v1");return await crypto.subtle.deriveKey({name:"PBKDF2",salt:a,iterations:this.PBKDF2_ITERATIONS,hash:"SHA-256"},s,{name:"AES-GCM",length:256},!1,["encrypt","decrypt"])},async saveKeyPair(){try{const e=await crypto.subtle.exportKey("spki",this.keyPair.publicKey),t=this.arrayBufferToBase64(e);this.keyGenerationDate=this.keyGenerationDate||Date.now();try{return await this._idbPut("keys","privateKey",this.keyPair.privateKey),await this._idbPut("keys","publicKey",t),await this._idbPut("keys","meta",{createdAt:this.keyGenerationDate,version:"4.0",type:"non-exportable"}),console.log("âœ“ E2EE:Private key persisted securely in IndexedDB(structured clone)"),!0}catch(e){return await this._idbPut("keys","publicKey",t).catch((()=>{})),await this._idbPut("keys","meta",{createdAt:this.keyGenerationDate,version:"4.0",type:"session-only"}).catch((()=>{})),console.warn("âš  E2EE:IndexedDB persistence failed for private key. Keys will be session-only.",e),!1}}catch(e){return console.warn("âš  E2EE:saveKeyPair error:",e),!1}},async loadKeyPair(){try{const e=await this._idbGet("keys","privateKey"),t=await this._idbGet("keys","publicKey"),r=await this._idbGet("keys","meta");if(!e||!t)return console.log("E2EE:No persisted keys found"),!1;if(e&&e instanceof CryptoKey&&e.usages.includes("decrypt")){const s=this.base64ToArrayBuffer(t),a=await crypto.subtle.importKey("spki",s,{name:"RSA-OAEP",hash:"SHA-256"},!0,["encrypt"]);return this.keyPair={publicKey:a,privateKey:e},this.keyGenerationDate=r&&r.createdAt?r.createdAt:Date.now(),this.areKeysExpired(this.keyGenerationDate)&&(console.warn("âš  E2EE:Keys expired,regeneration recommended"),this.showKeyExpiryWarning()),console.log("âœ“ E2EE:Loaded non-exportable keys from IndexedDB"),!0}return console.log("E2EE:Private key in storage is not a CryptoKey â€” treating as absent"),!1}catch(e){return console.error("E2EE:Failed to load keys:",e),!1}},areKeysExpired(e){if(!e)return!1;return Date.now()-e>24*this.KEY_EXPIRY_DAYS*60*60*1e3},showKeyExpiryWarning(){"undefined"!=typeof window&&window.UIManager&&window.UIManager.showNotification("âš ï¸ Your encryption keys are older than 30 days. Consider regenerating for better security.","warning")},async init(){const e=await this.loadKeyPair();return await this.loadVerifiedPeers(),await this.loadSecureUsers(),await this._getOrCreateLocalMasterKey(),e?(this.startKeyRotationScheduler(),!0):(console.log("E2EE:Generating new RSA key pair(non-exportable)..."),this.keyPair=await crypto.subtle.generateKey({name:"RSA-OAEP",modulusLength:2048,publicExponent:new Uint8Array([1,0,1]),hash:"SHA-256"},!1,["encrypt","decrypt"]),this.keyGenerationDate=Date.now(),await this.saveKeyPair(),console.log("âœ“ E2EE:New key pair created"),this.startKeyRotationScheduler(),!0)},async rotateKeys(){return console.log("E2EE:Manual key rotation requested..."),await this.rotateKeysWithMessages()},async clearKeys(){this.stopKeyRotationScheduler(),this.keyPair=null,this.localMasterKey=null,this.peerPublicKeys.clear(),this.peerFingerprints.clear(),this.verifiedPeers.clear(),this.keyGenerationDate=null,this.decryptionFailures.clear(),this.sessionKeys.clear(),this.messageStore.clear();try{await this._idbDelete("keys","privateKey"),await this._idbDelete("keys","publicKey"),await this._idbDelete("keys","meta"),await this._idbDelete("keys","verifiedPeers"),await this._idbDelete("keys","localMasterKey"),await this._idbClear("roomKeys")}catch(e){console.error("E2EE:Error clearing keys:",e)}console.log("âœ“ E2EE:All keys cleared")},async _generateAndPersistRoomKey(e,t,r){const s=await crypto.subtle.generateKey({name:"AES-GCM",length:256},!1,["encrypt","decrypt"]),a=await crypto.subtle.generateKey({name:"HMAC",hash:"SHA-256"},!1,["sign","verify"]),o={aes:s,hmac:a};try{const i=await crypto.subtle.wrapKey("raw",s,r,"AES-KW"),n=await crypto.subtle.wrapKey("raw",a,r,"AES-KW");await this._idbPut("roomKeys",e,{wrappedAes:this.arrayBufferToBase64(i),wrappedHmac:this.arrayBufferToBase64(n),created:Date.now(),username:t}),this.sessionKeys.set(e,o)}catch(t){console.warn("E2EE:Could not persist wrapped room key. Key is session-only:",t),this.sessionKeys.set(e,o)}return o},async getOrCreateRoomKey(e,t){if(this.sessionKeys.has(e))return this.sessionKeys.get(e);const r=await this._getOrCreateLocalMasterKey();try{const s=await this._idbGet("roomKeys",e);if(s&&s.wrappedAes){const t=this.base64ToArrayBuffer(s.wrappedAes),a=this.base64ToArrayBuffer(s.wrappedHmac),o=await crypto.subtle.unwrapKey("raw",t,r,"AES-KW",{name:"AES-GCM",length:256},!0,["encrypt","decrypt","wrapKey","unwrapKey"]),i={aes:o,hmac:await crypto.subtle.unwrapKey("raw",a,r,"AES-KW",{name:"HMAC",hash:"SHA-256"},!0,["sign","verify"])};return this.sessionKeys.set(e,i),console.log(`âœ“ E2EE:Loaded LMK-wrapped room key for ${e}`),i}if(s&&s.key){console.warn(`E2EE:Found legacy raw room key for ${e}. Migrating to LMK-wrapped format.`);const a=await crypto.subtle.importKey("raw",this.base64ToArrayBuffer(s.key),{name:"AES-GCM",length:256},!0,["encrypt","decrypt","wrapKey","unwrapKey"]),o={aes:a,hmac:s.hmac?await crypto.subtle.importKey("raw",this.base64ToArrayBuffer(s.hmac),{name:"HMAC",hash:"SHA-256"},!0,["sign","verify"]):null};return this.sessionKeys.set(e,o),await this._generateAndPersistRoomKey(e,t,r),await this._idbDelete("roomKeys",e),o}}catch(e){console.warn("E2EE:Could not load or unwrap room key,generating new:",e)}return await this._generateAndPersistRoomKey(e,t,r)},async storeMessage(e,t,r,s){try{const a=await this.getOrCreateRoomKey(e,s),o=crypto.getRandomValues(new Uint8Array(12)),i=new TextEncoder,n=JSON.stringify({content:t.content||t.message,sender:t.sender||t.username,timestamp:t.timestamp||Date.now(),isOutgoing:r}),c=i.encode(`${e}|${n.sender}|${n.timestamp}`),y=await crypto.subtle.encrypt({name:"AES-GCM",iv:o,additionalData:c},a.aes,i.encode(n)),l=new Uint8Array(y.byteLength+c.byteLength);l.set(new Uint8Array(y),0),l.set(c,y.byteLength);const d=await crypto.subtle.sign("HMAC",a.hmac,l);await this._idbPut("messages",null,{room:e,encrypted:this.arrayBufferToBase64(y),iv:this.arrayBufferToBase64(o),hmac:this.arrayBufferToBase64(d),timestamp:n.timestamp}),console.log("âœ“ E2EE:Message stored securely with mandatory HMAC and AAD")}catch(e){console.error("E2EE:Failed to store message:",e)}},async loadMessages(e,t){try{const r=await this.getOrCreateRoomKey(e,t),s=await this._idbGetAll("messages","room",e),a=[],o=new TextDecoder,i=new TextEncoder;for(const t of s)try{const s=this.base64ToArrayBuffer(t.encrypted),n=this.base64ToArrayBuffer(t.iv),c=this.base64ToArrayBuffer(t.hmac),y=JSON.parse(o.decode(await crypto.subtle.decrypt({name:"AES-GCM",iv:n},r.aes,s))).sender,l=i.encode(`${e}|${y}|${t.timestamp}`),d=new Uint8Array(s.byteLength+l.byteLength);d.set(new Uint8Array(s),0),d.set(l,s.byteLength);if(!await crypto.subtle.verify("HMAC",r.hmac,c,d)){console.warn(`E2EE:HMAC verification failed for message in room ${e}. Skipping message.`);continue}const u=await crypto.subtle.decrypt({name:"AES-GCM",iv:n,additionalData:l},r.aes,s),p=JSON.parse(o.decode(u));a.push(p)}catch(e){console.warn("E2EE:Could not decrypt message(HMAC failure or corruption):",e)}return a.sort(((e,t)=>e.timestamp-t.timestamp)),console.log(`âœ“ E2EE:Loaded ${a.length}verified messages for ${e}`),a}catch(e){return console.error("E2EE:Failed to load messages:",e),[]}},async clearOldMessages(){try{const e=Date.now()-24*this.MESSAGE_RETENTION_DAYS*60*60*1e3,t=await this._openIDB(),r=t.transaction(["messages"],"readwrite"),s=r.objectStore("messages").index("timestamp"),a=IDBKeyRange.upperBound(e);let o=0;const i=s.openCursor(a);await new Promise(((e,t)=>{i.onsuccess=t=>{const r=t.target.result;r?(r.delete(),o++,r.continue()):e()},i.onerror=()=>t(i.error)})),t.close(),console.log(`âœ“ E2EE:Deleted ${o}old messages`)}catch(e){console.error("E2EE:Failed to clear old messages:",e)}},async getPublicKeyFingerprint(e=null){try{const t=e||this.keyPair.publicKey,r=await crypto.subtle.exportKey("spki",t),s=await crypto.subtle.digest("SHA-256",r);return Array.from(new Uint8Array(s)).map((e=>e.toString(16).padStart(2,"0"))).join("").match(/.{1,4}/g).join(" ").toUpperCase().substring(0,47)}catch(e){return console.error("E2EE:Failed to generate fingerprint:",e),null}},async getShortFingerprint(e=null){const t=await this.getPublicKeyFingerprint(e);return t?t.split(" ").slice(0,6).join(" "):null},async storePeerFingerprint(e,t){const r=await this.getPublicKeyFingerprint(t);r&&this.peerFingerprints.set(e,r)},async verifyShortCode(e,t){const r=this.peerFingerprints.get(e);if(!r)return console.warn(`E2EE:No fingerprint for ${e}to compare.`),!1;const s=r.split(" ").slice(0,6).join(" ").toUpperCase(),a=t.trim().toUpperCase(),o=s===a;return o?(this.verifiedPeers.add(e),await this.saveVerifiedPeers(),console.log(`âœ“ E2EE:Verified ${e}via short code match`)):console.error(`âœ— E2EE:Short code mismatch for ${e}. Expected:${s},Got:${a}`),o},async verifyPeerFingerprint(e,t){const r=this.peerFingerprints.get(e);if(!r)return console.warn(`E2EE:No fingerprint for ${e}`),!1;const s=r===t;return s?(this.verifiedPeers.add(e),await this.saveVerifiedPeers(),console.log(`âœ“ E2EE:Verified ${e}`)):console.error(`âœ— E2EE:Fingerprint mismatch for ${e}`),s},markPeerVerified(e){this.verifiedPeers.add(e),this.autoAcceptedPeers.delete(e),this.saveVerifiedPeers()},markPeerAutoAccepted(e){this.verifiedPeers.has(e)||(this.autoAcceptedPeers.add(e),this.saveVerifiedPeers())},isPeerVerified(e){return this.verifiedPeers.has(e)},isPeerAutoAccepted(e){return this.autoAcceptedPeers.has(e)},async saveVerifiedPeers(){try{const e={verified:Array.from(this.verifiedPeers),autoAccepted:Array.from(this.autoAcceptedPeers)};await this._idbPut("keys","verifiedPeers",e)}catch(e){console.error("E2EE:Failed to save verified peers:",e)}},async loadVerifiedPeers(){try{const e=await this._idbGet("keys","verifiedPeers");e&&(e.verified&&Array.isArray(e.verified)&&(this.verifiedPeers=new Set(e.verified)),e.autoAccepted&&Array.isArray(e.autoAccepted)&&(this.autoAcceptedPeers=new Set(e.autoAccepted)))}catch(e){console.error("E2EE:Failed to load verified peers:",e)}},async exportPublicKey(){try{const e=await crypto.subtle.exportKey("spki",this.keyPair.publicKey);return this.arrayBufferToBase64(e)}catch(e){return console.error("E2EE:Failed to export public key:",e),null}},async importPublicKey(e,t){try{const r=this.base64ToArrayBuffer(t),s=await crypto.subtle.importKey("spki",r,{name:"RSA-OAEP",hash:"SHA-256"},!0,["encrypt"]);return this.peerPublicKeys.set(e,s),await this.storePeerFingerprint(e,s),!0}catch(t){return console.error("E2EE:Failed to import public key for",e,t),!1}},async encryptMessage(e,t){try{const r=await crypto.subtle.generateKey({name:"AES-GCM",length:256},!0,["encrypt","decrypt"]),s=crypto.getRandomValues(new Uint8Array(12)),a=new TextEncoder,o=await crypto.subtle.encrypt({name:"AES-GCM",iv:s},r,a.encode(e)),i=await crypto.subtle.exportKey("raw",r),n={};for(const e of t){let t=this.peerPublicKeys.get(e);if(t||"undefined"==typeof window||e!==window.E2EE_SELF_USERNAME||(t=this.keyPair.publicKey),t)try{const r=await crypto.subtle.encrypt({name:"RSA-OAEP"},t,i);n[e]=this.arrayBufferToBase64(r)}catch(t){console.error(`E2EE:RSA encrypt failed for ${e}`,t)}else console.warn(`E2EE:No public key for ${e}`)}return{iv:this.arrayBufferToBase64(s),encryptedMessage:this.arrayBufferToBase64(o),encryptedKeys:n,version:"4.0",timestamp:Date.now()}}catch(e){return console.error("E2EE:Encryption failed:",e),null}},recordDecryptionFailure(e,t){this.decryptionFailures.has(e)||this.decryptionFailures.set(e,{attempts:0,lastError:null,timestamp:Date.now()});const r=this.decryptionFailures.get(e);r.attempts++,r.lastError=t.message,r.timestamp=Date.now()},shouldRetryDecryption(e){if(!this.decryptionFailures.has(e))return!0;return this.decryptionFailures.get(e).attempts<this.MAX_DECRYPTION_RETRIES},async decryptMessage(e,t,r=null){try{if(!t)return"[Not encrypted for you]";if(r&&!this.shouldRetryDecryption(r)){return`[Decryption Failed:${this.decryptionFailures.get(r).lastError}]`}const s=this.base64ToArrayBuffer(t),a=await crypto.subtle.decrypt({name:"RSA-OAEP"},this.keyPair.privateKey,s),o=await crypto.subtle.importKey("raw",a,{name:"AES-GCM",length:256},!1,["decrypt"]),i=await crypto.subtle.decrypt({name:"AES-GCM",iv:this.base64ToArrayBuffer(e.iv)},o,this.base64ToArrayBuffer(e.encryptedMessage));return r&&this.decryptionFailures.delete(r),(new TextDecoder).decode(i)}catch(e){return console.error("E2EE:Decryption failed:",e),r&&this.recordDecryptionFailure(r,e),"OperationError"===e.name?"[Decryption Failed:Invalid key or corrupted data]":"InvalidAccessError"===e.name?"[Decryption Failed:Access denied]":`[Decryption Failed:${e.message}]`}},arrayBufferToBase64(e){const t=new Uint8Array(e);let r="";for(let e=0;e<t.length;e++)r+=String.fromCharCode(t[e]);return btoa(r)},base64ToArrayBuffer(e){const t=atob(e),r=new Uint8Array(t.length);for(let e=0;e<t.length;e++)r[e]=t.charCodeAt(e);return r.buffer},getDebugInfo(){return{hasKeyPair:!!this.keyPair,hasLMK:!!this.localMasterKey,keyAge:this.keyGenerationDate?Date.now()-this.keyGenerationDate:null,keysExpired:this.keyGenerationDate?this.areKeysExpired(this.keyGenerationDate):null,needsRotation:this.needsKeyRotation(),peerCount:this.peerPublicKeys.size,verifiedPeerCount:this.verifiedPeers.size,failedDecryptions:this.decryptionFailures.size,secureStorage:!0,sessionKeys:this.sessionKeys.size,rotationSchedulerActive:!!this.keyRotationInterval,PBKDF2_ITERATIONS:this.PBKDF2_ITERATIONS,version:"4.0-patched"}},async saveSecureUsers(){try{const e={secureUsers:Array.from(this.secureUsers),roomSecurityMode:Array.from(this.roomSecurityMode.entries())};await this._idbPut("keys","secureUsers",e),console.log("âœ“ E2EE: Secure users saved")}catch(e){console.error("E2EE: Failed to save secure users:",e)}},async loadSecureUsers(){try{const e=await this._idbGet("keys","secureUsers");e&&(e.secureUsers&&Array.isArray(e.secureUsers)&&(this.secureUsers=new Set(e.secureUsers)),e.roomSecurityMode&&Array.isArray(e.roomSecurityMode)&&(this.roomSecurityMode=new Map(e.roomSecurityMode)),console.log("âœ“ E2EE: Loaded secure users configuration"))}catch(e){console.error("E2EE: Failed to load secure users:",e)}},markUserAsSecure(e,t){const r=`${t}:${e}`;this.secureUsers.add(r),this.saveSecureUsers(),console.log(`âœ“ E2EE: ${e} marked as secure in ${t}`)},markRoomAsSecure(e){this.roomSecurityMode.set(e,"secure-all"),this.saveSecureUsers(),console.log(`âœ“ E2EE: Room ${e} marked as secure for all`)},isUserSecure(e,t){const r=`${t}:${e}`;return this.secureUsers.has(r)||"secure-all"===this.roomSecurityMode.get(t)},isRoomSecureForAll(e){return"secure-all"===this.roomSecurityMode.get(e)},getEnhancedRecipients(e,t){const r=new Set(e);if(this.isRoomSecureForAll(t)){for(const e of this.peerPublicKeys.keys())r.add(e);console.log(`E2EE: Room is secure-all, encrypting for ${r.size} users`)}else for(const e of this.secureUsers){const[s,a]=e.split(":");s===t&&this.peerPublicKeys.has(a)&&r.add(a)}return Array.from(r)}};"undefined"!=typeof module&&(module.exports=E2EE),"undefined"!=typeof window&&(window.E2EE=E2EE);
